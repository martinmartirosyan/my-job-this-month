<!DOCTYPE html>
<html lang="hy">

<head>
    <link rel="stylesheet" href=".//kayq.css">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>


<body>


    <nav>
        <ul>
            <li> <a href="index.html">topics</a>
                <ul>
                    <li><a href="#"></a><a href="#lezuner">What Is Programming</a> </li>
                    <li> <a href="#"></a><a href="#stack"> Stack vs Heap Memory</a> </li>
                    <li> <a href="#"></a> <a href="#computer">Computer</a> </li>
                    <li> <a href="#"></a><a href="#kompilator">Compiler vs Interpreter</a> </li>
                    <li> <a href="#"></a><a href="#git">Git</a> </li>
                    <li> <a href="#"></a><a href="#data">Data types</a></li>
                    <li><a href="#"></a> <a href="#flowchart">Flowchart Vs Pseudocode</a></li>
                    <li><a href="#"></a><a href="#viewport">viewport</a></li>
                    <li><a href="#"></a> <a href="#Hardwar">Hardware & Software</a></li>
                    <li><a href="#"></a> <a href="#my-referat">My Referat</a></li>
                    <li><a href="#"></a> <a href="#operators">Operators</a></li>
                </ul>
            </li>
        </ul>



    </nav>





    <div class="himnakan">
        <div class="texekutyun">

            <h1>ծրագրաորմանը վերաբերվող հայալեզու նյութեր </h1>
        </div>
        <div class="lezuner">
            <h2 id="lezuner">
                Ինչ է ծրագրավորումը
                Ծրագրավորման լեզուներ
                Տիպեր և տարբերություններ
                Պրակտիկ կիրառությոն
            </h2>
            <p>
                <br><strong>High-level vs. low-level-Բարձր մակարդակի եւ ցածր մակարդակի լեզուներ</strong>
                Ամենամեծ գործոնը, որ տարբերում է բարձր եւ ցածր մակարդակի ծրագրավորման լեզուները, այն է, թե արդյոք այդ
                լեզուն հեշտությամբ կարելի է հասկանալ մարդկային ծրագրավորողի կամ համակարգչի միջոցով։ Ցածր մակարդակի
                լեզուները մեքենայական են, ինչի շնորհիվ հիշողության օգտագործման տեսանկյունից դրանք շատ արդյունավետ են,
                բայց դժվար է հասկանալ առանց հավաքողի օգնության։ Քանի որ նրանք այնքան էլ հարմար չեն մարդկանց, նրանք
                այլեւս լայնորեն չեն օգտագործվում: Օրինակներից են մեքենայական կոդը եւ հավաքման լեզուները։
                <br><strong> High-level languages</strong>,(Բարձր մակարդակի լեզուներ),մյուս կողմից, ավելի քիչ
                հիշողության արդյունավետ են, բայց շատ ավելի մարդկային բարեկամական: Դրա շնորհիվ նրանք ավելի հեշտությամբ են
                գրում, հասկանում, պահպանում եւ դեբուգ անում։ Այսօր գործածության մեջ գտնվող ամենատարածված ծրագրավորման
                լեզուները համարվում են բարձր մակարդակի լեզուներ:
                <strong>Interpreted vs. compiled languages</strong>
                Մեկնաբանված եւ համակարգված լեզուների տարբերությունը կապված է այն բանի հետ, թե ինչպես են դրանք
                փոխակերպում բարձր մակարդակի կոդը եւ դարձնում այն համակարգչի կողմից մատչելի։ Մեկնաբանված լեզուների
                օգնությամբ կոդն անցնում է մի ծրագրի, որը կոչվում է ինտերպրետատոր, որը կարդում եւ իրականացնում է կոդի
                տողը տող առ տող։ Սա ավելի ճկուն եւ հարթակային դարձնելու հակվածություն ունի։
                interpreted-ի լեզուների օրինակներն են
            </p>

            <ul>
                <li>Python</li>
                <li>JavaScript</li>
                <li> PHP</li>
                <li> Ruby</li>
            </ul>
            <p> Կոմպիլացված լեզուները անցնում են կառուցվող քայլով, որտեղ ամբողջ ծրագիրը վերածվում է մեքենայական կոդի: Սա
                ավելի արագ է իրագործում, բայց նաեւ նշանակում է, որ ցանկացած ժամանակ, երբ անհրաժեշտ է, պետք է նորից
                կազմել կամ «կառուցել» ծրագիրը։
                Կոմպիլացված լեզուների օրինակներն են</p>

            <ul>
                <li>C++</li>
                <li> C#</li>
                <li> Rust</li>
                <li> Erlang</li>
            </ul>
            <p> <strong> Տիպեր</strong>
                <br><strong> 1. Procedural programming languages(Ընթացակարգային ծրագրավորման լեզուներ)</strong>
                Ընթացակարգային լեզուն հետեւում է հայտարարությունների կամ հրամանների հաջորդականությանը, որպեսզի հասնի
                ցանկալի արդյունքի: Քայլերի յուրաքանչյուր շարք կոչվում է ընթացակարգ, եւ այդ լեզուներից որեւէ մեկում գրված
                ծրագիրը կունենա մեկ կամ մի քանի ընթացակարգ դրա ներսում: Ընթացակարգային լեզուների ընդհանուր օրինակներն
                են.
            </p>

            <ul>
                <li> C++</li>
                <li> Java</li>
                <li> Pascal</li>
                <li> BASIC</li>
            </ul>
            <p> <br><strong> 2. Ֆունկցիոնալ ծրագրավորման լեզուներ</strong>
                Ֆունկցիոնալ լեզուները ոչ թե կենտրոնանում են դրույթների իրականացման վրա, այլ կենտրոնանում են
                մաթեմատիկական ֆունկցիաների եւ գնահատականների ելքի վրա։ Յուրաքանչյուր ֆունկցիա– կոդի վերամշակելի մոդուլ–
                կատարում է որոշակի առաջադրանք եւ վերադարձնում արդյունքը: Արդյունքը կփոխվի՝ կախված այն բանից, թե ինչ
                տվյալներ եք մուտքագրում ֆունկցիայի մեջ։ Որոշ հայտնի ֆունկցիոնալ ծրագրավորման լեզուներ ներառում են.
            </p>
            <ul>
                <li> Scala</li>
                <li> Erlang</li>
                <li> Haskell</li>
                <li> Elixir</li>
                <li> F#</li>
            </ul>
            <p><strong>3. Օբյեկտ կողմնորոշված ծրագրավորման լեզուներ</strong>
                Լեզվի այս տեսակը ծրագրային է վերաբերվում որպես տվյալների եւ ծրագրի տարրերից կազմված օբյեկտների խումբ,
                որը հայտնի է որպես հատկանիշներ եւ մեթոդներ: Օբյեկտները կարող են կրկին օգտագործվեն ծրագրի շրջանակներում
                կամ այլ ծրագրերում: Սա այն դարձնում է հայտնի լեզվի տեսակ բարդ ծրագրերի համար, քանի որ կոդը ավելի հեշտ է
                վերամշակել եւ մասշտաբավորել: Որոշ ընդհանուր օբյեկտ կողմնորոշված ծրագրավորման (OOP) լեզուները ներառում
                են.
            </p>
            <ul>
                <li>Java</li>
                <li>Python</li>
                <li> PHP</li>
                <li> C++</li>
                <li> Ruby</li>
            </ul>
            <p><strong> 4. Scripting languages</strong>
                <br>Ծրագրավորողները սքրիփթային լեզուների միջոցով ավտոմատացնում են կրկնվող առաջադրանքները, կառավարում
                են դինամիկ վեբ կոնտենտը կամ աջակցում են ավելի մեծ ծրագրերում կատարվող գործընթացներին։ Որոշ ընդհանուր
                գրային լեզուներ ներառում են.
            </p>
            <ul>
                <li> PHP</li>
                <li> Ruby</li>
                <li> Python</li>
                <li> bash</li>
                <li> Perl</li>
                <li> Node.js</li>
            </ul>
            <p><strong>5. Տրամաբանական ծրագրավորման լեզուներ</strong>
                Փոխանակ համակարգչին ասելու, թե ինչ անել, տրամաբանական ծրագրավորման լեզուն արտահայտում է մի շարք փաստեր
                եւ կանոններ, որոնք կօգնեն համակարգչին, թե ինչպես որոշումներ կայացնել։ Լոգիական լեզուների որոշ օրինակներ
                ներառում են.
            </p>
            <ul>
                <li> Prolog</li>
                <li>Absys</li>
                <li> Datalog</li>
                <li> Alma-0</li>
            </ul>
            <p><strong> Front-end vs. back-end լեզուներ</strong>
                <strong>Front-end լեզուները</strong>հիմնականում մտահոգված են ծրագրային ապահովման «օգտագործող» ոլորտով:
                Առջեւի ծայրը վերաբերվում է բոլոր տեքստերին, գույներին, կոճակներին, պատկերներին եւ նավարկությանը, որոնց
                բախվելու է օգտագործողը ձեր կայքը կամ դիմումը կողմնորոշվելիս: Ցանկացած մարդ, ով ունի գրաֆիկական դիզայն
                կամ արվեստ, կարող է ավելի ոգեշնչվել՝ սկսելու սովորել առաջին շրջանի լեզուներից մեկը։
                Առաջային ծրագրավորման լեզուների որոշ օրինակներ ներառում են.
            </p>
            <ul>
                <li> HTML</li>
                <li>CSS</li>
                <li> JavaScript</li>
                <li> React</li>
            </ul>
            <p><strong>Back-end լեզուները</strong> վերաբերում են ծրագրային ապահովման սերվերի կողմի պահպանմանը եւ
                մանիպուլյացիային: Սա այն ծրագրի մի մասն է, որի հետ օգտվողը ուղղակիորեն չի շփվում, այլ աջակցում է նրանց
                փորձառությանը վարագույրների ետեւում։ Սա ներառում է տվյալների ճարտարապետությունը, սցենարը եւ կապը
                դիմումների եւ հիմքում ընկած տվյալների բազաների միջեւ:
                Ցանկացած մարդ, ով ունի մաթեմատիկայի կամ ճարտարագիտության փորձ, կարող է ավելի շատ հետաքրքրվել հետին
                զարգացմամբ։
                Back-end ծրագրավորման լեզուների որոշ օրինակներ ներառում են
            </p>
            <ul>
                <li>JavaScript</li>
                <li> PHP</li>
                <li>Java</li>
                <li> Python</li>
                <li> Ruby</li>
                <li> C#</li>
            </ul>

        </div>
        <div class="computer">
            <p>
            <h1 id="computer">computer-Համակարգիչ</h1>
            <h2> Համակարգիչների դասակարգումն ըստ չափի</h2>
            <p>Վակուումային խողովակները կամ հատուկ հարմարեցված խողովակները
                - կամ նույնիսկ մեխանիկական կարգավորումը - օգտագործվել են համակարգիչների առաջին սերնդում:
                Դրանք ավելի դանդաղ էին, ավելի շատ էներգիա էին
                օգտագործում եւ ծրագրավորման առումով ավելի քիչ ճկուն էին։
                Դիսկրետ տրանզիստորները օգտագործվել են երկրորդ սերնդի համակարգիչներում,
                որոնք ավելի փոքր էին։ Նրանք նաեւ ավելի քիչ էներգիա էին ծախսում :
                Ինտեգրված շրջանները աշխատում էին երրորդ սերնդի համակարգիչներում։
                Յուրաքանչյուր ինտեգրալ շրջանի տրանզիստորների խտությունը 1960-ականների
                համակարգիչների եւ այսօրվա համակարգիչների միջեւ եղած հիմնական տարբերությունն է:
                Միկրոպրոցեսորներն օգտագործվում են չորրորդ սերնդի համակարգիչներում: Միկրոպրոցեսորներն օգտագործվում են,
                քանի որ միլիոնավոր ԻԿ-ներ լցված են մեկ սիլիկոնային չիպի վրա։ Անձնական բջջային սարքերի՝ լափթոփների,
                պլանշետների եւ սմարթֆոնների ներմուծմամբ համակարգիչների ձեւավորման գործոնը նվազել է, բարելավվել են
                առաջադրանքների մշակումը եւ գրաֆիկական թարգմանությունը, եւ այն դարձել է ավելի մարտկոցով աշխատող։
            <h2> Համակարգիչների դասակարգումն ըստ նպատակի</h2>
            Միկրոհամակարգիչները, որոնք երբեմն հայտնի են որպես անհատական համակարգիչներ, քսաներորդ դարի վերջին
            դարձել են ամենատարածված տիպը։ «Միկրոհամակարգիչ» բառը ստեղծվել է միակուսակցական միկրոպրոցեսորային
            համակարգերի ներմուծմամբ։ Minicomputers, հայտնի է նաեւ որպես mid-range համակարգիչներ կամ Superminis,
            բազմաօգտագործվող համակարգչի տեսակ, որը ընկնում է ինչ-որ տեղ հաշվարկման սպեկտրի մեջտեղում։
            «supermini computer» տերմինը, կամ պարզապես «supermini», որը ստեղծվել է ավելի հզոր
            մինիհամակարգիչների նկարագրման համար, որոնք ունակ էին մրցել հիմնական ֆլմագների հետ:
            Սուպերհամակարգիչը համակարգիչ է, որը գտնվում է ընթացիկ մշակման հզորության կտրուկ ծայրին եւ կենտրոնացած է
            ծանր թվային հաշվարկներ պահանջող առաջադրանքներ կատարելու վրա։ «Supercomputer» բառը մի քիչ սխալ է: Այսօրվա
            գերհամակարգիչները հակված են դառնալ վաղվա միջին համակարգչի նշանը:
            Իրական թվերի մաթեմատիկական հավասարումների հաշվարկը լողացող կետային գործողության օրինակ է, որը չափվում է
            վայրկյանում
            լողացող կետով գործողություններով, կամ FLOPS-ով։ Այս համակարգիչները մշակվել են 1970-ականներին եւ ամենաարագ եւ
            ամենահզոր համակարգիչներն են։
            <h2>Համակարգիչների դասակարգումն ըստ տեսակի</h2>
            սերվերը համակարգիչ է, որը նվիրված է մեկ կամ մի քանի ծառայություններ մատուցելուն եւ ենթադրվում է, որ այն
            վստահելի է,
            կարող է աշխատել մի քանի տարի եւ ունակ է սխալի դեպքում արժեքավոր դիագնոստիկա ապահովել: Ավելի փոքր սերվերներից
            շատերը
            պարզապես անձնական համակարգիչներ են, որոնք ստեղծվել են այլ համակարգիչներին ծառայություններ մատուցելու համար։
            Աշխատանքային բեմերը համակարգիչներ են, որոնք նախատեսված են մեկ օգտագործողին սպասարկելու համար եւ կարող են
            ներառել
            եզակի hardware առաջխաղացումներ, որոնք առկա չեն անձնական համակարգչի մեջ, ներկայումս արտահայտությունը
            օգտագործվում է
            բարձր արդյունավետությամբ սարքերի հետ աշխատասեղանի համակարգիչներին դիմելու համար:
            Տեղեկատվական սարքավորումները համակարգիչներ են, որոնք հատուկ կառուցված են որոշակի «օգտագործողի
            համար հարմար» աշխատանք կատարելու համար:Այս տերմինը հիմնականում օգտագործվում է մարտկոցով աշխատող շարժական
            սարքերի նկարագրման համար։
            Ներդրված համակարգիչները այն համակարգիչներն են, որոնք կառուցվում են մեխանիզմի կամ սարքի մեջ եւ հաճախ վարում
            են մի ծրագիր,
            որը պահվում է ոչ-ցցիկ հիշողության մեջ եւ բացառապես նախատեսված է այդ սարքավորումը գործարկելու համար:
            <h2>Համակարգիչների դասակարգումն ըստ օգտագործման</h2>
            Հանրային համակարգիչը այն համակարգիչն է, որը հասանելի է հասարակությանը եւ, ընդհանուր առմամբ, կրակով
            պարսպապատված է
            եւ սահմանափակվում է միայն նախապես տեղադրված ծրագրերով։Անհատական համակարգիչը ունի միայն մեկ օգտատեր, ով ունի
            լիարժեք
            հասանելիություն բոլոր hardware ռեսուրսներին, ամբողջական վերահսկողություն է ապահովում համակարգչի բոլոր
            կողմերի նկատմամբ,
            ինչպես նաեւ կարող է տեղադրել եւ ջնջել ծրագիրը։ Անձնական ֆայլերը սովորաբար պահվում են անձնական
            համակարգիչներում:
            Կիսված համակարգիչը այն համակարգիչն է, որի վրա տարբեր ժամանակներում կարող են մուտք գործել բազմաթիվ անհատներ։
            Սակայն նրանք պետք է ունենային օգտագործողի անուններ եւ ծածկագրեր, որոնք նշանակվում էին երկար ժամանակ, իրենց
            տեսած ֆայլերով եւ համակարգչի պարամետրերով, որոնք հարմարեցված էին իրենց հատուկ հաշվին՝ ի տարբերություն
            հանրային համակարգիչների։
            Ցուցադրման համակարգիչները համակարգիչներ են, որոնք օգտագործվում են միայն սահմանափակ քանակությամբ ինֆորմացիա
            ցուցադրելու համար խանութում,
            հանդիպման կամ առեւտրի ցուցահանդեսում եւ հազվադեպ են հրավառվում։ Նման համակարգիչները սովորաբար օգտագործվում
            եւ պահպանվում են
            որպես սարքավորումներ, այլ ոչ թե որպես կարեւոր ֆայլերի հիմնական պահեստ։
            <h2> Համակարգիչների դասակարգումը ըստ ֆունկցիայի</h2>
            Վաղ համակարգիչները պետք է օգտագործվեին միայն հաշվարկների համար։ Արդյունաբերական հեղափոխության սկզբում երկար,
            ձանձրալի աշխատանքներ ավտոմատացնելու համար կառուցվեցին որոշակի մեխանիկական սարքեր։ Բացի այդ, քսաներորդ դարի
            սկզբին բարդ էլեկտրամեքենաները կատարել են հատուկ անալոգային հաշվարկներ, իսկ առաջին թվային էլեկտրոնային
            հաշվարկային մեքենաները կառուցվել են World-ի ընթացքում
            Երկրորդ պատերազմ. Այդ ժամանակից ի վեր համակարգչային արագությունը, հզորությունը եւ բազմաչափությունը
            զգալիորեն աճել են, իսկ տրանզիստորների թիվը արագորեն աճում է։
            Ժամանակակից համակարգիչը սովորաբար բաղկացած է առնվազն մեկ պրոցեսորային տարրից եւ ինչ-որ տիպի
            համակարգչային հիշողությունից։ Մշակման տարրը կատարում է թվաբանական եւ տրամաբանական գործողություններ,
            իսկ հաջորդականության եւ վերահսկման միավորը փոխում է գործողությունների հաջորդականությունը՝ ի պատասխան
            պահպանված տվյալների։
            Մուտքային եւ ելքային սարքերը, ինչպես նաեւ երկու դերերը կատարող սարքերը պերիֆերիկ սարքեր են, որոնք թույլ են
            տալիս
            տեղեկատվությունը դուրս բերել արտաքին աղբյուրից եւ հնարավորություն են տալիս գործողությունների արդյունքը:
            <h2>Համակարգիչների դասակարգում, ըստ չափի, օգտագործման, տեսակի և Նպատակի Բոլոր փաստերը</h2>
            <p> Համակարգիչների դասակարգումը կարեւոր ուղղություն է հասկանալու համար այն սարքերի տարբեր տեսակները,
                որոնք այսօր առկա են շուկայում: Կարեւոր է նշել, որ համակարգիչների դասակարգումը հիմնված է մի քանի
                գործոնների վրա, ինչպիսիք են չափը, օգտագործումը, տեսակը եւ նպատակը։ Այս հոդվածում մանրամասնորեն
                կքննենք այս գործոնները եւ կներկայացնենք համակարգիչների դասակարգման ամբողջական պատկերացումը։
                Համակարգիչների դասակարգման ամենատարածված մեթոդներից մեկը հիմնված է չափերի վրա։ Համակարգիչների
                չափերը կարող են տարբերվել փոքր ձեռքի սարքերից մինչեւ հիմնական հիմնական համակարգիչները։
                Համակարգիչների ամենափոքր կատեգորիան հայտնի է որպես ձեռքի համակարգիչներ կամ անհատական թվային
                օգնականներ (PDAs)։ Այս սարքերը այնքան փոքր են, որ կարող են տեղավորվել ձեռքի ափի մեջ եւ սովորաբար
                օգտագործվում են անձնական գործերի համար, ինչպիսիք են գրաֆիկ կազմելը, գրառումներ անելը եւ ինտերնետից
                օգտվելը։
                Լապտերները եւ պլանշետները նույնպես համարվում են փոքր համակարգիչներ։ Դրանք ավելի հզոր են, քան ձեռքի
                սարքերը։
                Համակարգիչների դասակարգման մեկ այլ եղանակ էլ հիմնված է օգտագործման վրա։ Որոշ համակարգիչներ նախատեսված են
                հատուկ առաջադրանքների համար, ինչպիսիք են խաղային, գրաֆիկական դիզայնը կամ վիդեո խմբագրումը։ Այս
                համակարգիչները
                հայտնի են որպես հատուկ համակարգիչներ։ Սովորաբար նրանք ունեն բարձր վերջավորություն ունեցող սարքեր եւ
                ծրագրային
                ապահովում, որոնք օպտիմալացվում են հատուկ առաջադրանքների համար։ Մյուս կողմից, ընդհանուր նպատակային
                համակարգիչները
                նախատեսված են լայն շրջանակի համար եւ հարմար են ամենօրյա օգտագործման համար
                Համակարգիչների տեսակը նույնպես օգտագործվում է դրանք դասակարգելու համար։ Գոյություն ունի համակարգիչների
                երկու հիմնական տեսակ՝ անալոգ եւ թվային: Անալոգային համակարգիչները օգտագործվում են անընդհատ տվյալների
                մշակման համար, մինչդեռ թվային համակարգիչները օգտագործվում են դիսկրետ տվյալներ մշակելու համար։ Թվային
                համակարգիչներն ավելի լայն կիրառություն ունեն, քան անալոգային համակարգիչները եւ ավելի հաճախ
                են օգտագործվում այսօրվա շուկայում:
                Վերջիվերջո, համակարգիչների դասակարգումը կարող է նաեւ հիմնված լինել նպատակի վրա։ Անհատական համակարգիչները
                նախատեսված են անձնական օգտագործման համար, իսկ գործարար համակարգիչները նախատեսված են աշխատավայրում
                օգտագործելու համար:
                Սերվերները նախատեսված են մեծ քանակությամբ տվյալներ ձեռք բերելու եւ այլ համակարգիչներին ցանցային
                ծառայություններ
                մատուցելու համար: Սուպերհամակարգիչները ամենահզոր համակարգիչներն են եւ օգտագործվում են բարդ գիտական եւ
                ինժեներական սիմուլյացիաների համար։
                Ամփոփելով՝ համակարգիչների դասակարգումը կարեւոր ուղղություն է հասկանալու համար այն սարքերի տարբեր
                տեսակները,
                որոնք այսօր առկա են շուկայում: Այն հիմնված է մի քանի գործոնների վրա, ինչպիսիք են չափը, օգտագործումը,
                տեսակը
                եւ նպատակը։ Համակարգիչների դասակարգումը հասկանալը կարող է օգնել օգտագործողներին ճիշտ որոշումներ կայացնել
                համակարգիչ գնելիս կամ օգտագործելիս։</p>
        </div>
        <div class="stack">
            <h1 id="stack">
                Stack vs Heap Memory - Difference Between Them
            </h1>

            <h2>Ստակի եւ հեփի հիշողության հիմնական տարբերություն</h2>
            <ul>
                <li> Stack-ը գծային տվյալների կառուցվածք է, մինչդեռ Heap-ը հիերարխիկ տվյալների կառուցվածք է։</li>

                <li> Stack հիշողությունը երբեք չի բեկվի, մինչդեռ Heap հիշողությունը կարող է մասնատվել, քանի որ
                    հիշողության
                    բլոկները սկզբում բաշխվում են, իսկ հետո ազատվում:</li>

                <li> Stack-ը մուտք է գործում տեղական փոփոխականներ միայն այն ժամանակ, երբ Heap-ը թույլ է տալիս ձեզ մուտք
                    գործել փոփոխականներ ամբողջ աշխարհում:</li>

                <li> Stack փոփոխականները հնարավոր չէ վերամշակել, մինչդեռ Heap փոփոխականները կարող են վերամշակվել:</li>

                <li> Stack բաշխումը կատարվում է կոմպիլյատորի հրահանգներով, մինչդեռ Heap allocation եւ deallocation
                    կատարվում է ծրագրավորողի կողմից:</li>
            </ul>


            <h2>Հեփի օգտագործման առավելությունները </h2>

            <ul>
                <li>Heap-ն օգնում է գտնել մեծագույն եւ նվազագույն թիվը</li>
                <li> Աղբի հավաքումը գործում է կույտի հիշողության վրա, որպեսզի ազատի օբյեկտի օգտագործած հիշողությունը:
                </li>
                <li> Այն թույլ է տալիս ձեզ մուտք գործել փոփոխականներ ամբողջ աշխարհում:</li>
                <li> Heap-ը հիշողության չափի սահմանափակում չունի:</li>
            </ul>

            <h2> Սթեք օգտագործելու առավելությունները</h2>

            <ul>
                <li>Օգնում է ձեզ կառավարել տվյալները</li>
                <li> Այն թույլ է տալիս վերահսկել, թե ինչպես է հիշողությունը բաշխվում եւ լուծվում։</li>
                <li> Stack ավտոմատ մաքրում է օբյեկտը:</li>
                <li>Փոփոխականները հնարավոր չէ վերամշակել։</li>
            </ul>


            <h2> Սթեք օգտագործելու թերությունները</h2>
            <ul>
                <li>Stack հիշողությունը շատ սահմանափակ է:</li>
                <li> Կույտի վրա չափից շատ առարկաներ ստեղծելը կարող է մեծացնել կույտի գերհոսքի վտանգը։</li>
                <li> Հնարավոր չէ պատահական մուտք գործել։</li>
                <li> Փոփոխական պահուստը կգրվի գերանորոգված, ինչը երբեմն հանգեցնում է ֆունկցիայի կամ ծրագրի չսահմանված
                    վարքագծի:</li>
                <li> Կույտը կընկնի հիշողության տարածքից դուրս, ինչը կարող է հանգեցնել ոչ նորմալ ընդհատման։</li>
            </ul>


            <h2> Heap-ի օգտագործման թերությունները</h2>
            <ul>
                <li> Այն կարող է ապահովել առավելագույն հիշողությունը, որը OS-ը կարող է տրամադրել</li>
                <li>Հաշվարկելու համար ավելի շատ ժամանակ է հարկավոր։</li>
                <li> Հիշողության կառավարումը ավելի բարդ է կուտակման հիշողության մեջ, քանի որ այն օգտագործվում է ամբողջ
                    աշխարհում։</li>
                <li> Չափից շատ ժամանակ է պահանջվում մահապատժի ենթարկվելու համար ՝ համեմատած կույտի հետ </li>
            </ul>
        </div>
        <div class="m">
            <h1 id="kompilator">Compiler vs Interpreter</h1>
            <p>

                Ինտերպրետատորները(թարգմանիչ) և կոմպիլյատորները(կազմող) պատասխանատու են ծրագրավորման լեզուն կամ
                սցենարը (բարձր մակարդակի լեզուն) մեքենայական կոդի վերածելու համար: Բայց եթե երկու ծրագրերն էլ
                նույնն են անում, ինչո՞վ են դրանք տարբերվում: Եկե՛ք պարզենք:
            <h2>Կոմպիլյատոր`</h2>
            Կոմպիլյատորը (անգլ.՝ compiler) ծրագիր է, որը փոխակերպում է ծրագրավորման լեզվով գրված սկզբանական կոդը
            ( անգլ.՝ source code) այլ ծրագրային լեզվով(ելքային լեզվի, անգլ.՝ target language) կոդի, որը հիմնականում ունի
            բինար տեսք և հայտնի է օբյեկտային կոդ
            (անգլ.՝ object code) անվանմամբ։ Սկզբնական կոդի փոխակերպման ամենատարածված պատճառը այն է որ ստեղծվի կատարվող
            ծրագիր
            (անգլ.՝ executable program): Այն կարող է կատարել բոլոր նշված օպերացիաները


            <ul>
                <li>լեքսիկական վերլուծություն ( անգլ.՝ lexical analysis) – Այս փուլում սկզբնական ֆայլի սիմվոլների
                    հաջորդականությունը փոխակերպվում է թոքենների հաջորդականության։</li>
                <li>սինտակտիկական (քերականական) անալիզ (անգլ.՝ Parsing) – թոքենների հաջորդականությունը փոխակերպվում է
                    վերլուծության ծառի (parse tree):</li>
                <li>
                    սեմանտիկական (իմաստային) անալիզ (անգլ.՝ semantic analysis) – վերլուծության ծառը մշակվում է իմաստը
                    հաստատելու նմատակով։ Օրինակ՝ իդենտիֆիկատորների կապը դրանց հայտարարմանը, տիպերին, համատեղելիության
                    ստուգումը և այլն։ Արդյունքը հիմնականում կոչվում է կոդի միրջանկյալ ներկայացում (անգլ.՝ intermediate
                    representation) և կարող է լինել վերլուծության ծառի լրացում, նոր ծառ, աբստրակտ հրամանների խումբ կամ
                    այլ բան՝ հարմար հետագա աշխատանքին։</li>
                <li>կոդի օպտիմիզացիա ( անգլ.՝ code optimization) – կատարվում է ավելորդ կոնստրուկցիաների հեռացում և կոդի
                    պարզեցում՝ իմաստը պահպանելով։</li>
                <li>կոդի գեներացիա (անգլ.՝ code generation) – միջանկյալ ներկայացումից առաջանում է ելքային կոդ (անգլ.՝
                    target code)։</li>
            </ul>
            <br>Այսպիսով, կոմպիլյատորը վերցնում է ծրագիրն ամբողջությամբ և փոխակերպում այն ​​գործարկվող համակարգչային
            կոդի:
            Սա պահանջում է մի ամբողջ ծրագիր, քանի որ համակարգիչը հասկանում է միայն երկուական կոդ: Ուստի կոմպիլյատորի
            խնդիրն է գործարկվող ծրագիրը վերածել մեքենայի կոդի, որը ճանաչվում է համակարգչի կողմից:

            <p>Կոմպիլյացնող ծրագրավորման լեզուների օրինակներ են C, C++, Java-ն:</p>

            <h2>Ինտերպրետատոր</h2>
            <p>Ինտերպրետատորը (անգլ.՝ interpreter) ծրագիր է, որն ուղղակիորեն կատարում է ծրագրավորման կամ սկրիպտավորման
                լեզուներով գրված հրամաններ, առանց դրանք նախապես կոմպիլյացնելով մեքենայական լեզվի ծրագրի։ Ինտերպրետատորը
                ծրագրի կատարման համար հիմնականում օգտագործում է հետևյալ ստրատեգիաներից մեկը՝</p>

            <p>
            <ul>
                <li>վերլուծել (անգլ.՝ parse) սկզբնական կոդը և ուղղակիորեն կատարել,</li>
                <li>թարգմանել սկզբնական կոդը, ինչ որ միջանկյալ տեսքի և իրականացնել այն,</li>
                <li>հստակ իրականացնել պահպանված նախակոմպիլյացված (անգլ.՝ precompiled) կոդը՝ կոմպիլյատորի կողմից կազմված,
                    որը հանդիսանում է ինտերպրետատորի համակարգի մի մաս։</li>
            </ul>

            <p>Այսինքն ինտերպրետատորը մեքենայական ծրագիր է, որն ուղղակիորեն կատարում է մի շարք հրահանգներ՝ առանց դրանք
                նախապես կոմպիլյացնելու: Ինտերպրետացվող լեզուների օրինակներ են Perl-ը, Python-ը, Matlab-ը, Javascript-ը,
                PHP-ն:</p>

            <p><br>Որպես վերը նշվածների կարճ ամփոփում՝ կարելի է նշել, որ թե՛ կոմպիլյատորը և թե՛
                ինտերպրետատորը կատարում են նույն գործառույթը՝ բարձր մակարդակի ծրագրավորման
                լեզուն փոխակերպելով մեքենայական կոդի: Այնուամենայնիվ, կոմպիլյատորը սկզբնական կոդը
                փոխակերպում է մեքենայի կոդի՝ ծրագիրը գործարկելուց առաջ: Ինտերպրետատորը կատարում է այս
                ֆունկցիան, երբ այն գործարկվում է, գործարկման հետ միաժամանակ:</p>

            <h2>Ինչպե՞ս է այս ամենն աշխատում</h2>
            <p>
                <strong>Կոմպիլյատորը</strong> նախ ստեղծում է ծրագիր: Այն վերլուծում է լեզվի բոլոր օպերատորներին`
                ստուգելու, թե դրանք ճիշտ են, թե՝ ոչ: Եթե ​​կոմպիլյատորը որևէ սխալ գտնի, այն համապատասխան
                հաղորդագրություն կտա և կդադարեցնի կոմպիլյացման պրոցեսը: Հակառակ դեպքում այն սկզբնաղբյուրը կոդը
                փոխակերպում է մեքենայական կոդի: Կոմպիլյատորը տարբեր կոդային ֆայլեր է կապում այն ​​ծրագրերի հետ, որոնք
                կարող եք գործարկվել(օրինակ .exe ֆորմատով): Դրանից հետո ծրագիրը մեկնարկվում է:

                <br> <strong>Ինտերպրետատորը</strong> նույնպես, առաջին հերթին ստեղծում է ծրագիր: Այն չի կապում ֆայլերը
                կամ չի ստեղծում մեքենայական կոդ. պարզապես ծրագրի կատարման ընթացքումտեղի է ունենում մուտքային
                օպերատորների կատարում՝ տող առ տող:
            </p>
            <h2>Առավելություններ և թերություններ</h2>
            <h3>Կոմպիլյատորի առավելությունները</h3>
            <p>
            <ul>
                <li>Ծրագրային կոդը բերվում է մեքենայական կոդի, ինչի իրականացման համար շատ ավելի քիչ ժամանակ է պահանջվում
                </li>
                <li> .exe ֆայլերն աշխատում են ավելի արագ, քան սկզբաղբյուր կոդը: Օբյեկտային ծրագրերը պահպանվում են և
                    կարող են գործարկվել ցանկացած պահի</li>
                <li> Օբյեկտային ծրագրեը երրորդ կողմից ավելի են պաշտպանված: Օգտագործողն այն ավելի դժվարությամբ կարող է
                    փոփոխել, քան սկզբնաղբյուր կոդը</li>
                <li> Կոմպիլյատորը սինտաքսային սխալների առկայությունը ստուգում է կոմպիլյացման ընթացքում, ինչը բացառում է
                    գործարկումից հետո սինտաքսային սխալի առաջացումը</li>
            </ul>

            <h3>Կոմպիլյատորի թերությունները</h3>
            <ul>
                <li>Քանզի թարգմանվում է ծրագիրն ամբողջությամբ, օգտագործվում է շատ ավելի մեծ մեքենայական հիշողության
                    ռեսուրս</li>
                <li>Յուրաքանչյուր փոփոխության համար պետք է փոխել սկզբնաղբյուր կոդը և կրկնել կոմպիլյացիայի պրոցեսը</li>
                <li> Նախքան վերջնական կատարվող ֆայլի ստեղծումը անհրաժեշտ է ստեղծել նաև օբյեկտային ծրագիր, ինչը ևս
                    ժամանակատար պրոցես է</li>
                <li>Սկզբնաղբյուր կոդը պետք է լինի 100% ճիշտ կատարվող ֆայլ ստեղծելու համա</li>
            </ul>
            <h3>Ինտերպրետատորի առավելությունները</h3>
            <ul>
                <li>Ինտերպրետատորը զգալիորեն թեթևացնում է սկզբնաղբյուր կոդի հետ աշխատանքը</li>
                <li>Այն միաժամանակ թարգմանում է մեկ հրահանգ, ուստի օգտագործում է նվազագույն քանակությամբ հիշողություն
                </li>
                <li>Ինտերպրետատորը կարող է սխալների մասին հաղորդագրությունները կապել կատարվող հրահանգների հետ, որը կարող
                    է օգտակար լինել վրիպազերծման (դեբագի) ժամանակ:</li>
            </ul>

            <h3>Ինտերպրետատորի թերությունները</h3>
            <ul>
                <li>Ամեն անգամ, երբ ծրագիրը կատարվում է, զգալի ժամանակ է վատնվում ինտերպրետացիայի վրա, ինչի հետևանքով
                    ձգձգում է կատարման ժամանակը:</li>
                <li>Ինտերպրետացվող ծրագրերը կարող են գործարկվել միայն այն համակարգիչների վրա, որոնք ունեն համապատասխան
                    ինտերպրետատորները:</li>
            </ul>
            <h2>Տարբերություններ</h2>
            <h3>Եզրափակենք կամպիլյատորի և ինտերպրետատորի տարբերությունները աղյուսակի միջոցով.</h3>

            <img src="comiler-interprerier-cycles.jpg.webp" alt="mmm">
            <table>
                <tr>
                    <th>Կամպիլյատոր</th>
                    <th>Ինտերպրետատոր</th>
                </tr>

                <tr>
                    <th>Կամպիլյատորը լեզվական պրոցեսսոր է, որը փոխարկում է բարձր մակարդակի լեզուն ցածրի, և հակառակը</th>
                    <th>Ինտերպրետատորը լեզվական պրոցեսսոր է, որը փոխարկում է բարձր մակարդակի լեզուն ցածրի, և հակառակը
                    </th>
                </tr>
                <tr>
                    <th>Մշակման է վերցնում ծրագիրն ամբողջությամբ</th>
                    <th>Մշակման է վերցնում ծրագրի հերթական տողը կամ ինստրուկցիան</th>
                </tr>
                <tr>
                    <th>Գեներացնում է միջանկյալ օբյեկտային ծրագիր</th>
                    <th>Չի գեներացնում միջանկյալ օբյեկտային ծրագիր</th>
                </tr>
                <tr>
                    <th>Կամպիլյացիան իրականացվում է կատարումից առաջ</th>
                    <th>Կամպիլյացիան և կատարումը տեղի են ունենում միաժամանակ</th>
                </tr>

                <tr>
                    <th>Համեմատաբար բարձր արագագործություն</th>
                    <th>Ցածր արագագործություն</th>
                </tr>
                <tr>
                    <th>Օբյեկտային ծրագիր ստեղծելու պատճառով առավել շատ հիշողություն է պահանջում</th>
                    <th>Առավել քիչ հիշողություն է պահանջում, քանի որ օբյեկտային ծրագիր չի ստեղծում</th>
                </tr>

                <tr>
                    <th>Սխալների մասին զգուշացումներն անում են միանգամից և կամպիլյացիայի ավարտից հետո</th>
                    <th>Յուրաքանչյուր սխալի հանդիպելուց անմիջապես կատարվում է զգուշացում</th>
                </tr>

                <tr>
                    <th>Սխալների հայտնաբերումը խրթին է</th>
                    <th>Հեշտորեն հայտնաբերվում են սխալները</th>
                </tr>

                <tr>
                    <th>Առավել էֆեկտիվ</th>
                    <th>Պակաս էֆեկտիվ</th>
                </tr>

                <tr>
                    <th>C, C++, C#, Scala, Typescript-ն օգտագործում են կամպիլյատոր</th>
                    <th>PHP, Perl, Python, Ruby-ն օգտագործում են ինտերպրետատոր</th>
                </tr>
            </table>

        </div>
        <div class="git">
            <h1 id="git">git</h1>
            <h2>Բաց կոդով բաշխված տարբերակի կառավարման համակարգ</h2>

            <p><strong>Կառավարման համակարգ.(Control System:)</strong> Սա հիմնականում նշանակում է, որ Git-ը
                բովանդակության հետագծող է: Այսպիսով, Git-ը կարող է օգտագործվել բովանդակություն պահելու համար. այն
                հիմնականում օգտագործվում է ծածկագիրը պահելու համար՝ իր տրամադրած այլ հնարավորությունների շնորհիվ:
                <strong> Տարբերակի վերահսկման համակարգ.(Version Control System)</strong> Git-ում պահվող կոդը
                շարունակվում է փոփոխվել, քանի որ ավելացվում է ավելի շատ կոդ: Բացի այդ, շատ մշակողներ կարող են
                զուգահեռաբար կոդ ավելացնել: Այսպիսով, Version Control System-ը օգնում է լուծել դա՝ պահպանելով կատարված
                փոփոխությունների պատմությունը: Նաև Git-ը տրամադրում է այնպիսի գործառույթներ, ինչպիսիք են
                ճյուղավորումները և միաձուլումները, որոնք ես կանդրադառնամ ավելի ուշ:
                <br><strong> Բաշխված տարբերակի կառավարման համակարգ.(Distributed Version Control System)</strong> Git-ն
                ունի հեռավոր պահոց, որը պահվում է սերվերում և տեղական պահոց, որը պահվում է յուրաքանչյուր մշակողի
                համակարգչում: Սա նշանակում է, որ կոդը ոչ միայն պահվում է կենտրոնական սերվերում, այլ կոդի ամբողջական
                պատճենն առկա է բոլոր մշակողների համակարգիչներում։ Git-ը բաշխված տարբերակի կառավարման համակարգ է, քանի որ
                կոդը առկա է յուրաքանչյուր մշակողի համակարգչում: Ես կբացատրեմ հեռավոր և տեղական պահեստների հայեցակարգը
                այս հոդվածում ավելի ուշ:
            </p>



            <h3>Ինչու է անհրաժեշտ Git-ի նման Տարբերակների վերահսկման համակարգ</h3>

            <p>Իրական կյանքի նախագծերը հիմնականում ունեն մի քանի ծրագրավորողներ, որոնք զուգահեռ աշխատում են: Այսպիսով,
                Git-ի նման տարբերակների վերահսկման համակարգ է անհրաժեշտ՝ համոզվելու համար, որ մշակողների միջև կոդի
                հակասություններ չլինեն:
                Բացի այդ, նման նախագծերում պահանջները հաճախ փոխվում են։ Այսպիսով, տարբերակի կառավարման համակարգը թույլ է
                տալիս ծրագրավորողներին վերադառնալ և վերադառնալ կոդի ավելի հին տարբերակին:
                Վերջապես, երբեմն մի քանի նախագծեր, որոնք իրականացվում են զուգահեռ, ներառում են նույն կոդերի բազան: Նման
                դեպքում Git-ում ճյուղավորվելու հայեցակարգը շատ կարևոր է։
            </p>
            <h3>Եկեք հիմա սկսենք օգտագործել Git-ը</h3>
            Բոլոր հասկացությունները միանգամից նշելու փոխարեն, ես կբացատրեմ Git-ի հասկացությունները օրինակի միջոցով,
            որպեսզի ավելի հեշտ լինի հետևել դրան:
            Ներբեռնեք git
            Այս հղումը պարունակում է մանրամասներ, թե ինչպես տեղադրել Git-ը բազմաթիվ օպերացիոն համակարգերում.
            <br><a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git"
                target="_blank">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>
            Ստուգեք, արդյոք Git-ը տեղադրված է, օգտագործելով հետևյալ հրամանը հրամանի տողում.
            git --version
            <h3>Ստեղծեք ձեր տեղական Git պահոցը (repo)</h3>
            <p>Ձեր համակարգչում ստեղծեք թղթապանակ ձեր նախագծի համար: Եկեք անվանենք նախագծի թղթապանակը simple-git-demo:
                Գնացեք ձեր նախագծի թղթապանակ և ծրագրին ավելացրեք տեղական Git պահոց՝ օգտագործելով հետևյալ հրամանները.
                <strong>git init</strong>
                Git init հրամանը նախագծին ավելացնում է տեղական Git պահոց:
            </p>
            <h3>Եկեք հիմա մի փոքր կոդ ավելացնենք</h3>
            <p>Նախագծի թղթապանակում ստեղծեք demo.txt անունով ֆայլ և դրանում ավելացրեք հետևյալ տեքստը.
                Սկզբնական բովանդակություն
                Այստեղ մենք իրական կոդի փոխարեն կցուցադրենք պարզ տեքստով, քանի որ այս հոդվածի հիմնական ուշադրությունը
                կենտրոնացած է Git-ի վրա և ոչ թե ծրագրավորման որևէ հատուկ լեզվի վրա:</p>
            <h3>Կոդի բեմադրություն և կատարում(Staging and Committing the code)</h3>
            <p>Կարգավորումն այն գործընթացն է, որի ընթացքում կոդը ավելացվում է տեղական պահեստում: Նախքան ծածկագիրը
                կատարելը, այն պետք է լինի բեմադրության տարածքում: Բեմադրման տարածքն այնտեղ է՝ հետևելու բոլոր ֆայլերին,
                որոնք պետք է կատարվեն:
                Ցանկացած ֆայլ, որը չի ավելացվել բեմադրության տարածքին, չի հաստատվի: Սա ծրագրավորողին տալիս է
                վերահսկողություն, թե որ ֆայլերը պետք է կատարվեն:</p>

            <h3>Բեմականացում(Staging-add)</h3>
            <p>Ֆայլը բեմադրելու համար օգտագործեք հետևյալ հրամանը.
                <br><strong>git add demo.txt</strong>
                <br>Եթե ցանկանում եք ավելացնել մի քանի ֆայլ, կարող եք օգտագործել.
                <br><strong>git add file1 file2 file3</strong>
                <br>Եթե ցանկանում եք ավելացնել ձեր նախագծի թղթապանակի ներսում գտնվող բոլոր ֆայլերը բեմադրության
                տարածք, օգտագործեք հետևյալ հրամանը.
                <br><strong>git add .</strong>
                Զգուշորեն օգտագործեք սա, քանի որ այն ավելացնում է ձեր նախագծի բոլոր ֆայլերն ու թղթապանակները
                բեմադրության տարածքում:
            </p>
            <h3>commit</h3>
            <p>Ֆայլը հանձնելու համար օգտագործեք հետևյալ հրամանը.
                <br>git commit -m «Initial Commit»
                <br>«Initial Commit»-ը ստանձնման հաղորդագրությունն է այստեղ: Մուտքագրեք համապատասխան հանձնման
                հաղորդագրություն՝ նշելու,
                <br> թե կոնկրետ ինչ կոդի փոփոխություններ են կատարվել տվյալ commit-ում:
            </p>
            <h2>Git Status և Git Log</h2>
            <p>Այժմ փոփոխեք demo.txt ֆայլը և ավելացրեք հետևյալ հատվածը.
                Սկզբնական բովանդակություն Լրացուցիչ բովանդակության ավելացում
                Կարգավիճակ
                <br>Օգտագործեք git status-ը՝ պարզելու համար, թե ինչ ֆայլեր են փոփոխված և ինչ ֆայլեր կան բեմադրման
                տարածքում. այն ցույց է տալիս նաև այլ տեղեկություններ, որոնք մենք առայժմ կարող ենք անտեսել:
                <br>Կարգավիճակը տեսնելու համար օգտագործեք հետևյալ հրամանը.
                <br><br><strong>git status</strong>
                <br>Կարգավիճակը ցույց է տալիս, որ demo.txt-ը փոփոխված է և դեռ բեմադրության տարածքում չէ:
                Այժմ եկեք ավելացնենք demo.txt-ը բեմականացման(staging) տարածքում և կատարենք այն՝ օգտագործելով հետևյալ
                հրամանները.
                git ավելացնել demo.txt git commit -m «demo.txt ֆայլը փոփոխված է»
            </p>
            <br><br><strong>log</strong>
            <p><br>Օգտագործեք git log-ը տպելու բոլոր պարտավորությունները, որոնք կատարվել են մինչ այժմ:
                Դրա համար օգտագործվող հրամանն է.</p>
            <p><br><strong>git log</strong>
                Գրանցամատյանը ցույց է տալիս յուրաքանչյուր commit-ի հեղինակին, կատարման ամսաթիվը և commit
                հաղորդագրությունը:</p>
            <h2>Մասնաճյուղերը</h2>
            <p>Մինչ այժմ մենք ոչ մի մասնաճյուղ չենք ստեղծել Git-ում: Լռելյայնորեն, Git-ի պարտավորությունները գնում են
                հիմնական մասնաճյուղ:</p>
            <h3>Ի՞նչ է մասնաճյուղը:</h3>
            <p>Մասնաճյուղը ոչ այլ ինչ է, եթե ոչ Git պահոցում վերջին պարտավորությունների ցուցիչ: Այսպիսով, ներկայումս մեր
                գլխավոր մասնաճյուղը ցուցիչ է երկրորդ commit «demo.txt ֆայլը փոփոխված է»:
                <br><strong>Ինչու են անհրաժեշտ մի քանի մասնաճյուղեր:</strong>
                <br>Բազմաթիվ մասնաճյուղեր են անհրաժեշտ՝ մի քանի զուգահեռ զարգացումներին աջակցելու համար: Տեսեք ստորև
                ներկայացված պատկերը՝ տեսնելու, թե ինչպես են աշխատում մասնաճյուղերը:
            </p>
            <br>
            <p>Սկզբում commit 1-ը և commit 2-ը կատարվում էին master մասնաճյուղում: Commit 2-ից հետո ստեղծվում է նոր
                մասնաճյուղ, որը կոչվում է «develop», և commit 3-ը և commit 4-ը ավելացվում են թեստային ճյուղին:</p>

            <p>Միևնույն ժամանակ, հիմնական մասնաճյուղին ավելացվում են տարբեր commit 3 և 4 commit: Այստեղ մենք տեսնում
                ենք, որ Commit 2-ից հետո երկու զուգահեռ զարգացումներ են կատարվում 2 առանձին ճյուղերում։</p>

            <p>Թեստային մասնաճյուղը և Master Branch-ը տարբերվում են այստեղ և ունեն տարբեր կոդ. develop Branch-ի կոդը
                կարելի է միավորել Master ճյուղի հետ՝ օգտագործելով git merge:</p>


            <h3>Ստեղծեք նոր մասնաճյուղ local լեզվով</h3>
            Ստեղծեք նոր մասնաճյուղ, որը կոչվում է թեստ՝ օգտագործելով հետևյալ հրամանը.
            <strong><br>git checkout -b "name"</strong>
            Այս հրամանը ստեղծում է թեստային ճյուղ:
            Մենք դեռ master ճյուղի համատեքստում ենք։ Թեստային ճյուղին անցնելու համար։ օգտագործեք հետևյալ հրամանը.
            <strong><br>git checkout "name"</strong>
            Այժմ մենք գտնվում ենք թեստային ճյուղում։
            Դուք կարող եք թվարկել տեղական բոլոր մասնաճյուղերը՝ օգտագործելով հետևյալ հրամանը.
            <strong>git branch</strong>
            <h3>Կատարեք որոշ պարտավորություններ Նոր branch-ում</h3>
            <p>Փոփոխեք demo.txt-ը՝ ավելացնելով հետևյալ հատվածը.
                Սկզբնական բովանդակություն Լրացուցիչ բովանդակության ավելացում Փորձնական մասնաճյուղից որոշ բովանդակության
                ավելացում
                Այժմ բեմադրեք և կատարեք հետևյալ հրամանները.
                git add demo.txt git commit -m «Test Branch Commit»
                Այս հանձնումը կատարվել է Test Branch-ում, և այժմ Test Branch-ը գերազանցում է Master Branch-ից 1
                commit-ով, քանի որ թեստային ճյուղը ներառում է նաև 2 պարտավորությունները հիմնական մասնաճյուղից:
                Դուք կարող եք ստուգել կատարման պատմությունը թեստային մասնաճյուղում՝ օգտագործելով.
                git log
            </p>
            <br><br>
            <h3>Միաձուլում-merging</h3>
            <p>Ներկայումս Test Branch-ն առաջ է անցնում Master-ից 1 commit-ով: Եկեք ասենք, որ այժմ մենք ցանկանում ենք, որ
                Test Branch-ի ամբողջ ծածկագիրը հետ բերվի Master Branch: Այստեղ շատ օգտակար է git merge-ը:</p>
            <p><strong>Կոդը թեստային ճյուղից հիմնական մասնաճյուղին միացնելու համար հետևեք հետևյալ քայլերին.</strong></p>
            <ul>
                <li>Նախ վերադառնաք գլխավոր մասնաճյուղ.</li>
                <li>git checkout Master</li>
                <li>Այնուհետև գործարկեք միաձուլման հրամանը.</li>
                <li>git marge text</li>
            </ul>
            <p>Այս 2 հրամանները գործարկելուց հետո միաձուլումը պետք է հաջող լինի: Այս օրինակում հակասություններ չկան:
                Բայց իրական նախագծերում կոնֆլիկտներ կլինեն, երբ միաձուլում կատարվի: Կոնֆլիկտի լուծումը մի բան է, որը
                գալիս է փորձի հետ, այնպես որ, երբ ավելի շատ աշխատեք Git-ի հետ, դուք կկարողանաք ձեռք բերել կոնֆլիկտների
                լուծումը:
                Գործարկեք git log-ը հիմա և կնկատեք, որ mastern ունի նաև 3 կոմիտացիա։</p>
            <h2>Հեռավոր Git Repository</h2>
            <p>Մինչ այժմ մենք աշխատում էինք միայն տեղական շտեմարանում։ Յուրաքանչյուր ծրագրավորող կաշխատի իր տեղական
                պահեստում, բայց ի վերջո, նրանք կդնեն կոդը հեռավոր պահոց: Երբ կոդը գտնվում է հեռավոր պահոցում, մյուս
                մշակողները կարող են տեսնել և փոփոխել այդ կոդը:</p>
            <h3>GitHub</h3>
            <p>Այստեղ մենք կօգտագործենք GitHub-ը հեռավոր պահեստի համար:
                Գնացեք <a href="https://github.com" target="_blank">https://github.com</a> և ստեղծեք հաշիվ:
            </p>
            <p><strong>GitHub-ի</strong> գլխավոր էջում գրանցվելուց հետո սեղմեք Start a Project՝ նոր Git պահոց ստեղծելու
                համար: Անվանեք պահեստին և սեղմեք «Create Repository»
                Անունը տվեք որպես git-blog-demo:
                Սա GitHub-ում կստեղծի հեռավոր պահոց:
            </p>
            <p>Պահեստի URL-ը ընդգծված մասն է https://github.com/your-repo/git-blog-demo.git
                Ձեր տեղական պահոցը հեռավոր պահեստին ուղղելու համար օգտագործեք հետևյալ հրամանը.
                <strong>git remote add origin [պահեստի url]</strong>
            </p>
            <h3>Git Push</h3>
            <p>Տեղական պահոցից ամբողջ ծածկագիրը հեռավոր պահոց մղելու համար օգտագործեք հետևյալ հրամանը.
                git push -u origin master
                Սա մղում է կոդը տեղական պահեստի հիմնական մասնաճյուղից դեպի հեռավոր պահեստի հիմնական մասնաճյուղ:</p>
            <h3>Լրացուցիչ հրամաններ</h3>
            <ul>
                <li><strong>Git Pull</strong>
                    git pull-ն օգտագործվում է վերջին փոփոխությունները հեռավոր պահոցից տեղական պահոց քաշելու համար:
                    Հեռավոր պահոցի կոդը շարունակաբար թարմացվում է տարբեր մշակողների կողմից, հետևաբար git pull-ը
                    անհրաժեշտ է.
                    git pull origin master</li>
                <li> <strong>Git Clone</strong>
                    git clone-ն օգտագործվում է գոյություն ունեցող հեռավոր պահեստը ձեր համակարգչում կլոնավորելու համար:
                    Սրա հրամանը հետևյալն է.
                    <br><strong> git clone [repository url]</strong>
                </li>
            </ul>
            <hr>
            <ul>
                <li>Git-ը դժվար է, և կան ճնշող քանակությամբ հրամաններ և հնարքներ, որոնք դուք կարող եք սովորել և
                    օգտագործել,
                    բայց,
                    երբ խոսքը վերաբերում է ամենօրյա զարգացմանը, կա Git հրամանների մի փոքր ենթախումբ, որը դուք, ամենայն
                    հավանականությամբ,
                    պատրաստվում եք օգտագործել անընդհատ: Ահա git հրամանների ցանկը, որոնք ես օգտագործում եմ ամեն օր</li>
                <li>The git status</li>
                <li>The git clone</li>
                <li>The git branch</li>
                <li>The git checkout</li>
                <li>The git pull</li>
                <li>The git push</li>
                <li>The git diff</li>
                <li>The git log</li>
                <li>The git reflog aka the life-saver</li>
                <li>The git rebase</li>
                <li>The git merge</li>
                <li>The git remote</li>
                <li>The git stash</li>
                <li>The git reset</li>
                <li>The git fetch</li>
                <li>The git cherry-pick</li>
                <li>The git commit</li>
                <li>The git add</li>
                <li>The git grep</li>
                <li>The git init</li>
            </ul>
        </div>
        <div class="data">
            <h1 id="data">Data types</h1>
            <p><strong>Համակարգիչը որոշում է, թե որքան տարածք պետք է պահվի հիշողության մեջ արժեքները պահելու համար՝
                </strong>
                ելնելով պահվող արժեքի տեսակից: Նշանակում է, որ ստեղծված տվյալների տեսակը իր համար կպահի հիշողության մեջ
                նախապես որոշված բիթերի քանակ՝ հիմնվելով տվյալ տեսակի տվյալներին անհրաժեշտ բիթերի քանակի վրա: Օրինակ՝ ինը
                համարի նման ամբողջ թիվը կարող է ներկայացվել հիշողության մեջ՝ օգտագործելով ընդամենը 4 բայթ, որը դուք
                կարող եք իմանալ, որ 4 X 8 բիթ է կամ 32 բիթ:</p>

            <p><strong>Ստեղնաշարից մուտքագրված մեկ տառը (նիշ) սկզբնական միկրոհամակարգիչներում պահանջում էր ընդամենը 8
                    բիթ: </strong>
                Այդ ժամանակ միկրոհամակարգչի նիշերի կոդավորման սխեմաները հիմնված էին թարգմանության աղյուսակի վրա, որը
                հայտնի էր որպես «ASCII» (արտասանվում է ass-key): Մեր օրերում միկրոհամակարգիչներն օգտագործում են
                16 բիթ (կամ 2 բայթ)՝ Unicode նիշերի կոդավորման հավաքածուն ներկայացնելու համար։ Իմաստ չի լինի 32 բիթ
                համակարգչի հիշողություն
                պահել միայն ստեղնաշարից մուտքագրված նիշերը պահելու համար, ինչը 16 բիթ հիշողություն կկորցնի ամեն անգամ,
                երբ նիշը պետք է պահվի հիշողության մեջ:</p>


            <p><strong>Տվյալների տեսակը կամ պարզապես տիպը տվյալների դասակարգումն է, որը կոմպիլյատորին կամ </strong>
                թարգմանչին ասում է, թե ինչպես է ծրագրավորողը մտադիր օգտագործել տվյալները: Տվյալների
                տեսակները նշում են տվյալների տեսակը, որոնց հետ դուք աշխատում եք ծրագրում: Տվյալների
                տեսակը սահմանում է տվյալների պահպանման համար անհրաժեշտ հիշողության չափը և տվյալների
                վրա կատարվող գործողությունների տեսակները: Համակարգչային ծրագրավորման լեզուներից շատերն
                աջակցում են տարբեր տեսակի տվյալների, օրինակ՝ իրական, ամբողջ թիվ, լարային կամ բուլյան:
                Տվյալների տեսակն ապահովում է արժեքների մի շարք, որոնցից արտահայտությունը (այսինքն՝ փոփոխական,
                ֆունկցիա...)
                կարող է վերցնել իր արժեքները: Տեսակը սահմանում է այն գործողությունները, որոնք կարող են կատարվել
                տվյալների
                վրա, տվյալների նշանակությունը և այդ տեսակի արժեքների պահպանման եղանակները: Տվյալների տեսակները
                խմբավորված
                են արժեքների տեսակների և հղման տեսակների: Արժեքի տվյալների տեսակները պահում են արժեքը կույտի վրա,
                մինչդեռ
                տեղեկատու տվյալների տեսակները գրում են հիշողության հասցեն կույտի վրա, որը ցույց է տալիս, թե որտեղ է
                սկսվում
                տվյալների արժեքը դինամիկ հիշողության մեջ (կույտ):</p>


            <p><strong>Արժեքը տվյալների դիսկրետ քանակություն է: Տիպի անդամներն այդ տեսակի արժեքներն են։</strong>
                Համակարգչային լեզուները տարբերվում են պարզունակ արժեքների տեսակների իրականացման հարցում,
                սակայն որոշ օրինակներ կլինեն զրոյական, չսահմանված, ճիշտ/կեղծ և թվային արժեքներ, ինչպես հետևյալը.
                1, 3.1459, «Chuck», «D», true:</p>

            <p> <strong>C++-ում տվյալների տեսակները հիմնականում բաժանվում են երկու տեսակի.</strong>
                Տվյալների պարզունակ տեսակներ. տվյալների այս տեսակները ներկառուցված կամ կանխորոշված
                տվյալների տեսակներ են և կարող են օգտագործվել ուղղակիորեն օգտագործողի կողմից փոփոխականներ
                հայտարարելու համար: Օրինակ՝ int, char, float, bool և այլն: C++-ում հասանելի պարզունակ տվյալների
                տեսակներն են.</p>
            <ul>

                <li>Ամբողջ թիվ(Integer) </li>
                <li> Բնավորություն(Character)</li>
                <li> Բուլյան(Boolean)</li>
                <li>Լողացող կետ(Floating Point)</li>
                <li>Կրկնակի լողացող կետ(Double Floating Point)</li>
                <li>Անարժեք կամ անվավեր (Valueless or Void)</li>
                <li> Լայն բնավորություն (Wide Character) </li>
            </ul>
            <p><strong>Java տվյալների տեսակները</strong></p>
            <p>Յուրաքանչյուր փոփոխական ունի տվյալների տեսակ, որը պատմում է, թե ինչպիսի տվյալներ են պահվում փոփոխականի
                մեջ: JavaScript-ում գոյություն ունի տվյալների երկու տեսակ:

                Նախնական տվյալների տեսակներ
                Ոչ նախնական տվյալների տեսակներ
                Նախնական տվյալների տիպերը։ JavaScript լեզվով տրամադրվող նախապատմական տվյալների տիպերը հայտնի են որպես
                նախնական տվյալների տիպեր։ Նախնական տվյալների տիպերը հայտնի են նաեւ որպես ներկառուցված տվյալների
                տեսակներ:

                Ստորեւ ներկայացված է Նախնական տվյալների տեսակների ցանկը՝ պատշաճ նկարագրերով եւ օրինակներով.</p>
            <p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank">Java
                    տվյալների տեսակները (պաշտոնական փաստաթղթեր)</a></p>
            <p><br><strong>Java ծրագրավորման լեզուն աջակցում է տվյալների հետևյալ պարզունակ տեսակներին.</strong></p>
            <ul>
                <li>byte</li>
                <li>short</li>
                <li>int</li>
                <li>long</li>
                <li>float</li>
                <li>double</li>
                <li>boolean</li>
                <li>char</li>
            </ul>
            <p><a href="https://docs.python.org/2/library/stdtypes.html" target="_blank">Python-ի ներկառուցված տեսակները
                    (պաշտոնական փաստաթղթեր)</a></p>

            <p>Python-ն ունի չորս պարզունակ տվյալների տեսակ.</p>
            <ul>
                <li>Integers</li>
                <li>Float</li>
                <li>Strings</li>
                <li>Boolean</li>
            </ul>
            <h2>C# տվյալների տեսակները</h2>
            <p>C#-ը տրամադրում է մի քանի <strong>ներկառուցված տվյալների տեսակներ</strong> <strong>.NET Framework-ի
                    միջոցով </strong>որը կարող է օգտագործվել ձեր ծրագրերում:
                Դուք կարող եք նաև սահմանել տվյալների նոր տեսակներ՝ սահմանելով ձեր սեփական տվյալների կառուցվածքը, օրինակ՝
                դասը կամ կառուցվածքը:</p>

            <p>Փոփոխականները համակարգչային հիշողության մեջ տվյալների պահպանման ժամանակավոր տարածք ստեղծելու միջոց են
                ծրագրի գործարկման ընթացքում:
                Փոփոխականները կոչվում են պահեստավորման վայրեր, որոնք պահում են արժեքներ: Այնուհետև մենք կարող ենք
                առբերել հիշողության մեջ պահված արժեքը՝
                օգտագործելով այն անունը (a.k.a. նույնացուցիչ), որը մենք նրան վերագրում ենք փոփոխականը հայտարարելիս:
                Մտածեք փոփոխականի մասին որպես տեղապահ
                կամ որոշակի չափի տուփ, որի վրա մենք կարող ենք անուն գրել՝ օգնելու մեզ հետագայում ծրագրային կերպով հետ
                կանչել տվյալները: Օրինակ, եկեք
                հայտարարենք age անունով փոփոխական, այնուհետև մենք կպահենք դրա մեջ արժեքը:</p>

            <p>Կոնստանտները անփոփոխ արժեքներ են, որոնք հայտնի են կոմպիլյացիայի ժամանակ և չեն փոխվում ծրագրի կյանքի
                ընթացքում:</p>
            <ul>
                <li>Բուլյան տվյալների տեսակները պահպանում են երկու հնարավոր արժեքներից մեկը՝ false կամ true (0 կամ 1
                    երկուական տարբերակով): Այնուամենայնիվ, bools-ը կարող է օգտագործվել ցանկացած տրամագծորեն հակառակ
                    արժեքներ ներկայացնելու համար, ինչպիսիք են վեր կամ վար, ձախ կամ աջ, ներս կամ դուրս, միացված կամ
                    անջատված և այլն: Bool փոփոխականի լռելյայն արժեքը false է:</li>

                <li>Բայթ տվյալների տեսակը օգտագործվում է 8-բիթանոց անստորագիր ամբողջ թիվը ներկայացնելու համար: Բայտը
                    անփոփոխ արժեքի տեսակ է, որը ներկայացնում է անստորագիր ամբողջ թվեր, որոնց արժեքները տատանվում են 0-ից
                    (որը ներկայացված է Byte.MinValue հաստատունով) մինչև 255 (որը ներկայացված է Byte.MaxValue
                    հաստատունով): .NET Framework-ը ներառում է նաև ստորագրված 8-բիթանոց ամբողջական արժեքի տեսակ՝ SByte,
                    որը ներկայացնում է արժեքներ, որոնք տատանվում են -128-ից մինչև 127:</li>

                <li>Int կամ Int32 (հատուկ C#-ին) անփոփոխ արժեքի տեսակ է, որը ներկայացնում է ստորագրված ամբողջ թվեր
                    արժեքներով, որոնք տատանվում են բացասական 2,147,483,648-ից (որը ներկայացված է Int32.MinValue
                    հաստատունով) մինչև դրական 2,147,483,647 (որը Intualt-ը ներկայացված է Thex-ով։ .NET Framework-ը
                    ներառում է նաև անստորագիր 32-բիթանոց ամբողջ արժեքի տեսակ՝ UInt32, որը ներկայացնում է արժեքներ, որոնք
                    տատանվում են 0-ից մինչև 4,294,967,295:</li>


                <li>Լողացող կետերի տեսակները (The Floating-Point Types) պարզ տեսակների ենթաբազմություն են և կարող են
                    սկզբնավորվել բառացիներով: Բոլոր լողացող կետերի տեսակները նույնպես արժեքային տեսակներ են: Լողացող
                    կետով թվային բոլոր տեսակներն աջակցում են թվաբանության, համեմատության և հավասարության օպերատորներին:
                </li>
            </ul>
            <p>Լողացող կետով արտահայտությունը կարող է պարունակել արժեքների հետևյալ հավաքածուները.</p>
            <ul>
                <li>Դրական և բացասական զրո</li>
                <li>Դրական և բացասական անսահմանություն</li>
                <li>Ոչ թվային արժեք (NaN)</li>
                <li>Ոչ զրոյական արժեքների վերջավոր բազմություն</li>
            </ul>
            <p>Այս արժեքների մասին լրացուցիչ տեղեկությունների համար տե՛ս IEEE ստանդարտ երկուական լողացող կետային
                թվաբանության համար, որը հասանելի է <a href="http://ieee.org" target="_blank">IEEE</a> կայքում:</p>
            <br>
            <p>float տվյալների տեսակը օգտագործում է չորս բայթ՝ տասնորդական թվեր պարունակող թվային արժեքներ պահելու
                համար:</p>

            <p>
                Կրկնակի արժեքի տեսակը ներկայացնում է կրկնակի ճշգրտությամբ 64-բիթանոց թիվ, որի արժեքները
                տատանվում են բացասական 1.79769313486232e308-ից մինչև դրական 1.79769313486232e308, ինչպես
                նաև դրական կամ բացասական զրո, PositiveInfinity, NegativeInfinity և ոչ թե թիվ: Այն նախատեսված է
                ներկայացնելու արժեքներ, որոնք չափազանց մեծ են (օրինակ՝ մոլորակների կամ գալակտիկաների միջև
                հեռավորությունները)
                կամ չափազանց փոքր (նյութի մոլեկուլային զանգվածը կիլոգրամներով) և որոնք հաճախ անճշտ են (օրինակ՝
                հեռավորությունը
                երկրից մինչև մեկ այլ արեգակնային համակարգ), Կրկնակի տեսակը համապատասխանում է IEC 60559:1989 (IEEE 754)
                ստանդարտին երկուական լողացող կետով թվաբանության համար:
            </p>
            <table class="tible">
                <tr>
                    <th class="h">Data Type </th>
                    <th class="h">Size </th>
                    <th class="h">Range Of Values </th>
                </tr>
                <tr>
                    <th>byte</th>
                    <th>1 byte</th>
                    <th class="q">0 to 255</th>
                </tr>
                <tr>
                    <th>char</th>
                    <th>2 bytes</th>
                    <th class="q">U+0000-ից մինչև U+ffff (Յունիկոդի նիշեր)</th>
                </tr>
                <tr>
                    <th>short</th>
                    <th>2 bytes</th>
                    <th class="q">-32,768 to 32,767</th>
                </tr>
                <tr>
                    <th>int</th>
                    <th>4 bytes</th>
                    <th class="q">-2,147,483,648 to 2,147,483,647</th>
                </tr>
                <tr>
                    <th>long</th>
                    <th>8 bytes</th>
                    <th class="q">-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</th>
                </tr>
                <tr>
                    <th>float</th>
                    <th>4 bytes</th>
                    <th class="q">±1.5 X 10-45 to ±3.4 X 1038</th>
                </tr>
                <tr>
                    <th>double</th>
                    <th>8 bytes</th>
                    <th class="q">±5.0e-324 to ±1.7e308</th>
                </tr>
                <tr>
                    <th>bool</th>
                    <th>2 bytes</th>
                    <th class="q">True or False</th>
                </tr>
                <tr>
                    <th>string</th>
                    <th>-</th>
                    <th class="q">zero or more unicode characters</th>
                </tr>
            </table>
            <p>Լարի հատկություններ
                C#-ում տողի տեսակն ունի երկու հատկություն.
                Նիշեր[ինդեքս]
                Ստանում է Char օբյեկտը ընթացիկ String օբյեկտում նշված դիրքում:
                Երկարություն
                Ընթացիկ տողի նիշերի քանակը:</p>
        </div>
        <div class="Flowchart">
            <h1 id="flowchart"> Flowchart Vs Pseudocode</h1>


            <p>Flowchart-ը եւ pseudocodը ծրագրի դրույթների միջոցով վերահսկման հոսքը ներկայացնելու եղանակներն են,
                ալգորիթմը, գործընթացը եւ այլն: Հոսքի եւ պսեւդոկոդի միջեւ նշանակալի տարբերությունն այն է, թե ինչպես են
                դրանք ներկայացնում վերահսկման հոսքը:</p>
            <p>Flowchart-ը ալգորիթմի գրաֆիկական ներկայացումն է։ Սակայն կեղծոդը ալգորիթմի տեքստի վրա հիմնված
                ներկայացումն է։ Դե, մենք կարող ենք այս հասկացությունները միասին օգտագործել ծրագրային ապահովման նախագծման
                համար, կամ նույնիսկ կարող ենք օգտագործել դրանք անկախ:</p>
            <h2>What is Flowchart</h2>
            <p>A flowchart- ը ապահովում է ծրագրի, համակարգի, ալգորիթմի կամ գործընթացի գրաֆիկական ներկայացումը: Այն
                իրենից ներկայացնում է հաջորդական քայլերի այն հավաքածուն, որին պետք է հետեւի ծրագիրը, համակարգը,
                ալգորիթմը կամ պրոցեսը ցանկալի արդյունքը ստանալու համար: Սովորաբար համակարգչային ծրագրավորման ոլորտում
                օգտագործում ենք հոսքային ծրագրավորում: Սակայն այն օգնում է ծրագրավորողներին եւ նրանց, ովքեր չունեն
                ծրագրավորման ծագում, հասկանալ ցանկացած պրոցեսի վերահսկման հոսքը։</p>
            <p>Ինչպես գիտենք, վիզուալներն ավելի լավ են արտահայտվում, քան բառերը, ինչը դարձավ flowchart-ի
                հանրաճանաչության պատճառը: Հոսքի համար նախատեսված կետերը նույնիսկ օգնում են բարելավել դեպքերի
                ուսումնասիրությունը կամ պլանավորել ցանկացած ալգորիթմի նախագծման ետեւում։</p>
            <p>Լավ ստեղծված հոսթատրոնն ավելի հեշտ է դարձնում փաստաթուղթը: Ահա թե ինչու տարբեր դաշտերից մարդիկ
                օգտագործում են հոսող սարքը, որպեսզի ավելի հեշտ հասկանան։ </p>

            <h3>Symbols of Flowchart-Ֆլոուշարի խորհրդանիշներ</h3>
            <p>Flowchart ստեղծելու համար անհրաժեշտ է հետեւել մի շարք ստանդարտների: Մենք գիտենք, որ ալգորիթմում կամ
                ծրագրում ունենք տարբեր տեսակի արտահայտություններ: Ինչպես, կա հաշվարկ, վիճակ, ցատկ, ցուցադրման հրահանգ եւ
                այլն: Այսպիսով, տարբեր տեսակի արտահայտություններ ներկայացնելու համար հոսքային շարֆն ունի տարբեր տեսակի
                սիմվոլներ:</p>

            <p>Ստորեւ բերված աղյուսակը ցույց է տալիս ձեզ տարբեր սիմվոլներ, որոնք մենք կարող ենք օգտագործել հոսքային
                վանդակներում եւ դրանց նշանակությունը:</p>
            <h2>Flowchart-ի տեսակները</h2>
            <h3>Պրոցեսոր Flowchart</h3>
            <p>Պրոցեսորային flowchart- ը ամենատարածված flowchart- ն է: Դրա ճկունությունը թույլ է տալիս օգտագործողներին
                կիրառել այն գրեթե ցանկացած բանի վրա, ինչպիսին է բիզնես պլանավորումը, մեքենան կամ համակարգը,
                ծրագրավորումը եւ այլն:</p>
            <p>Պրոցեսորը flowchart-ն օգնում է իր ընթերցողներին հասկանալ, թե ինչպես է գործելու տվյալ գործընթացը եւ ինչպես
                են գործերը կատարվելու ողջ գործընթացում:</p>
            <h3>Workflow Flowchart-Աշխատանքային հոսքի flowchart</h3>
            <p>Workflow flowchart-ն օգնում է ընթերցողներին հասկանալ համակարգի ներսում ինֆորմացիայի հոսքը: Այն
                արդյունավետորեն ցույց է տալիս, թե ինչպես է գործելու այդ պրոցեսը ։</p>
            <p>Այն իրենից ներկայացնում է այնպիսի բիզնես գործընթացներ, ինչպիսիք են, թե ինչպես է ավարտվելու յուրաքանչյուր
                գործընթացը, յուրաքանչյուր քայլին աշխատակիցների դերը, ինչ հաջորդականությամբ է ավարտվելու գործընթացը եւ
                այլն:</p>
            <h3> Swimlane Flowchart</h3>
            <p>Swimlane flowcharts- ը շատ օգտակար է տարբեր պրոցեսների միջեւ փոխազդեցությունը ցույց տալու համար: Այս
                հոսքային հատումը ցույց է տալիս ինֆորմացիայի հոսքը առանձին պրոցեսորների միջոցով:</p>

            <p><strong>Swimlane flowchart-ը </strong>բաժանվում է կատեգորիաների, որպեսզի յուրաքանչյուր բաժանմունք իմանա
                իր դերը այդ գործընթացում: Այսպիսով, Swimlane flowchart-ը յուրաքանչյուր բաժանմունքի պատասխանատվությունն
                ավելի հստակ է դարձնում այդ գործընթացում:</p>
            <h3>Տվյալների հոսքեր</h3>
            <p>Տվյալների հոսքի համարանիշը ներկայացնում է, թե ինչպես են տվյալները կամ տեղեկությունները տեղափոխվում
                համակարգ եւ դուրս գալիս: Այն նաեւ ներկայացնում է, թե ինչպես են տվյալները մշակվում համակարգի ներսում:</p>
            <h3>Flowchart-ի օրինակ</h3>
            Ներքեւում գտնվող հոսքի աղյուսակը սկզբում կարդում է երկու թվերը եւ համեմատում դրանք: Եթե առաջին թիվն ավելի
            մեծ է, ապա ստորաբաժնում կատարվում է; եթե պայմանը ճիշտ չէ, ապա հավելման կատարումն իրականացվում է
            <h2>Ի՞նչ է Pseudocode- ը:</h2>
            <p>Pseudocode-ը ալգորիթմի, պրոցեսի կամ ծրագրի աշխատանքը պարզ տեքստով անգլերեն լեզվով ներկայացնելու միջոց է։
                Pseudocode-ն օգնում է իր ստեղծողին արտահայտելու այն քայլերը, որոնք նրանք պարզել են, որպեսզի լուծեն մի
                խնդիր, որի համար կոդը հետագայում կգրվի։</p>
            <p>Սովորաբար համակարգչային ծրագրավորման բնագավառում օգտագործում ենք կեղծոդ: Այն օգնում է ծրագրավորողներին
                իրենց գաղափարները հաղորդել իրենց հաճախորդների հետ, ովքեր ոչ ծրագրավորման դաշտից են:</p>

            <p>Pseudocode ստեղծելիս, ստեղծողը ստիպված չէ անհանգստանալ սինտակտիկ սխալի համար, քանի որ այն պարզ անգլերեն
                լեզվով գրված կեղծ կոդ է։</p>

            <p><strong>Գուցե մտածում ես, թե ինչու պետք է գրենք կեղծոդը եւ անմիջապես չցատկենք կոդավորման։</strong></p>

            <br>
            <p>Pseudocode- ը շատ ավելի հեշտ է դարձնում իրերը: Կեղծ կոդով ծրագրավորողը նախապես գիտի, թե ինչ պետք է
                կոդավորել: Ի վերջո, ծրագրավորողը պետք է պսեւդոկոդով անգլերեն դրույթները փոխակերպի իրական կոդի՝
                կոդավորման համար նրանց օգտագործած ծրագրավորման լեզվի շարահյուսությամբ:</p>

            <h3>Ինչպե՞ս գրել Pseudocode:</h3>

            <p>Որպես այդպիսին, Pseudocode գրելու չափանիշներ չկան: Ստեղծողը կարող է օգտագործել կեղծ կոդի
                հայտարարությունները ներկայացնելու իրենց ձևը: Դա պայմանավորված է նրանով, որ կեղծ կոդը գրված չէ
                համակարգչի
                կարդալու համար: Դա համապատասխան մարդկանց հասկանալու համար է, ինչպիսիք են ծրագրավորողները,
                հաճախորդները,
                թիմի անդամները, ղեկավարները և այլն:
                Թեև մենք ասացինք, որ կեղծ կոդ գրելու համար նման ստանդարտներ չկան, այնուամենայնիվ կան մի քանի պարզ
                կանոններ, որոնց պետք է հետևել ընթեռնելի կեղծ կոդ ստեղծելու համար:</p>
            <ul>
                <li>Հայտարարության մեջ յուրաքանչյուր բառի սկզբնական տառերը պետք է լինեն մեծատառ:</li>
                <li>Յուրաքանչյուր Pseudocode հայտարարություն պետք է նշի մեկ գործողություն համակարգչի համար:</li>
                <li> Բազմատող հատվածը, ինչպես օրինակ՝ հայտարարությունների մի շարքը, որոնք պետք է կատարվեն, երբ
                    բավարարվում է
                    որոշակի պայման, կամ երբ ավարտվում է հանգույցը և այլն, պետք է ավարտվի END բանալի բառով:</li>
                <li>Pseudocode չպետք է լինի վերացական. այն պետք է լինի մանրամասն և բացատրի բոլոր քայլերը, որոնք
                    անհրաժեշտ են ցանկալի արդյունք ստանալու համար:</li>
                <li> Ստեղծողը պետք է օգտագործի ճիշտ անվանման կանոնները, քանի որ դա օգնում է ծրագրավորողին հետևել
                    կեղծ կոդը կոդավորման ընթացքում:</li>
                <li> Pseudocode հայտարարությունները պետք է անկախ լինեն ծրագրավորման որևէ լեզվից, որպեսզի ծրագրավորողի
                    համար հեշտ լինի այն կոդավորել ցանկացած ծրագրավորման լեզվով:</li>
                <li> Կեղծ կոդը պետք է լինի պարզ, ինքնաբացատրվող և ընթեռնելի:</li>
            </ul>
            <h2>Հիմնական տարբերությունները հոսքի գծապատկերի և Pseudocode-ի միջև</h2>
            <ul>
                <li>Հոսքի աղյուսակը ալգորիթմի պատկերային կամ գրաֆիկական ներկայացում է: Այնուամենայնիվ, Pseudocod-ը
                    ալգորիթմի տեքստային ներկայացումն է: Մենք գրում ենք կեղծ կոդի հայտարարություններ անգլերենով, և
                    յուրաքանչյուր հայտարարություն ներկայացնում է հրահանգ:</li>
                <li> Հոսքերի գծապատկերին չափազանց շատ մանրամասներ ավելացնելը բարդացնում է այն: Այնուամենայնիվ,
                    Pseudocode-ը ը
                    բավականին ճկուն է մանրամասներ ավելացնելու համար, քանի որ այն չի մեծացնում դրա բարդությունը:</li>
                <li> Ստեղծվելուց հետո հեշտ չէ փոփոխել հոսքի գծապատկերը: Մյուս կողմից, կեղծկոդում փոփոխությունները հեշտ
                    են:</li>
                <li>Հոսքերի գծապատկեր ստեղծելու համար մենք պետք է թվարկենք որոշակի տարրեր, ինչպիսիք են ադամանդե տուփը
                    որոշումների կայացման համար, կլորացված տուփը սկզբի և կանգառի համար, սլաքները՝ հսկողության հոսքը ցույց
                    տալու համար և այլն: Այնուամենայնիվ, Pseudocode ստեղծելու ստանդարտներ չկան. նույնիսկ եթե այդպիսիք
                    կան,
                    դրանք տարբերվում են ընկերությունից ընկերություն:</li>
                <li>Հոսքերի գծապատկերները համեմատաբար հեշտ են հասկանալ, քան կեղծ կոդերը: Քանի որ Pseudocode ունի
                    ալգորիթմի կամ ծրագրի պատմողական ներկայացումը, ինչը բարդացնում է իրերը հասկանալը: Այնուամենայնիվ,
                    սխեմաները կարող են ցույց տալ կառավարման հոսքը կոդի միջոցով, ինչը հեշտացնում է այն հասկանալը:</li>
                <li>Հոսքերի գծապատկերը շահավետ է փոքր չափերի ալգորիթմներ կամ ծրագրեր ներկայացնելու համար, քանի որ
                    դժվարանում է ցույց տալ հսկիչ հոսքը հոսքի գծապատկերում մեծ չափի ալգորիթմի համար: Ընդհակառակը,
                    Pseudocode
                    օգտվում է ինչպես փոքր, այնպես էլ մեծ չափերի ալգորիթմներից:</li>
            </ul>
            <h3>Համեմատական աղյուսակ</h3>
            <table class="table2">
                <tr>
                    <th class="himnakan-th">Համեմատության հիմք</th>
                    <th class="himnakan-th">Flowchart</th>
                    <th class="himnakan-th">Pseudocode</th>
                </tr>
                <tr>
                    <th>Ներկայացուցչություն</th>
                    <th>Ալգորիթմի պատկերային ներկայացում</th>
                    <th>Ալգորիթմի տեքստի վրա հիմնված ներկայացում</th>
                </tr>
                <tr>
                    <th>Մանրամասնում</th>
                    <th> Չափազանց շատ մանրամասներ ավելացնելը կարող է բարդացնել հոսքի գծապատկերը</th>
                    <th>Pseudocode ճկուն է մանրամասներ ավելացնելու համար</th>
                </tr>
                <tr>
                    <th>Փոփոխություն</th>
                    <th>Նրա կառուցվածքը դիմադրում է փոփոխությանը</th>
                    <th>Հեշտ է փոփոխել</th>
                </tr>

                <tr>
                    <th>Կառուցվածք</th>
                    <th>Գոյություն ունի հատուկ տարրերի ցանկ, որոնք օգտագործվում են սխեմա ստեղծելու համար</th>
                    <th>Չկան ստանդարտներ կամ գործիքներ, որոնք պահանջվում են Pseudocode-ը ստեղծելու համար</th>
                </tr>
                <tr>
                    <th>Հասկանալը</th>
                    <th>Հեշտ է հասկանալ</th>
                    <th>Դժվար է հասկանալ</th>
                </tr>

                <tr>
                    <th>Շահավետ</th>
                    <th>Հոսքերի գծապատկերները շահավետ են ավելի փոքր կոդերի համար</th>
                    <th>Pseudocode-ը շահավետ են ավելի մեծ ծրագրավորման կոդերի համար</th>
                </tr>
            </table>
        </div>
        <div class="viewport">
            <h1 id="viewport">Viewport</h1>
            <p>Այս հոդվածը նկարագրում է, թե ինչպես օգտագործել «viewport» meta թեգը՝ դիտակետի չափն ու ձևը կառավարելու
                համար:</p>


            <h2>ֆոն</h2>

            Բրաուզերի տեսադաշտը այն պատուհանի տարածքն է, որտեղ կարելի է տեսնել վեբ բովանդակությունը: Սա հաճախ նույն չափը
            չէ, ինչ վերարտադրված էջը, որի դեպքում զննարկիչը տրամադրում է ոլորման տողեր, որպեսզի օգտագործողը կարողանա
            շրջել շուրջը և մուտք գործել ամբողջ բովանդակությունը:

            Որոշ շարժական սարքեր և այլ նեղ էկրաններ էջերը ներկայացնում են վիրտուալ պատուհանում կամ տեսադաշտում, որը
            սովորաբար ավելի լայն է, քան էկրանը, և այնուհետև կրճատում են ստացված արդյունքը, որպեսզի բոլորը միանգամից
            տեսանելի լինեն: Այնուհետև օգտատերերը կարող են շրջել և մեծացնել էջի տարբեր հատվածները տեսնելու համար: Օրինակ,
            եթե շարժական էկրանն ունի 640px լայնություն, էջերը կարող են ցուցադրվել 980px վիրտուալ տեսադաշտով, այնուհետև
            այն կփոքրացվի՝ տեղավորվելու 640px տարածության մեջ:

            Սա արվում է, քանի որ ոչ բոլոր էջերն են օպտիմիզացված բջջայինի համար և կոտրվում են (կամ գոնե վատ տեսք ունեն),
            երբ ցուցադրվում են փոքր տեսադաշտի լայնությամբ: Այս վիրտուալ տեսադաշտը միջոց է՝ ոչ բջջային օպտիմիզացված
            կայքերն ընդհանուր առմամբ ավելի լավ տեսք հաղորդելու նեղ էկրանով սարքերում:

            Այնուամենայնիվ, այս մեխանիզմը այնքան էլ լավ չէ այն էջերի համար, որոնք օպտիմիզացված են մեդիա հարցումների
            օգտագործմամբ նեղ էկրանների համար. եթե վիրտուալ տեսադաշտը, օրինակ, 980px է, 640px կամ 480px կամ ավելի փոքր
            չափերով մեդիա հարցումները երբեք չեն օգտագործվի՝ սահմանափակելով այդպիսիների արդյունավետությունը։ արձագանքող
            նախագծման տեխնիկա. Տեսադաշտի մետա պիտակը մեղմացնում է վիրտուալ տեսադաշտի այս խնդիրը նեղ էկրանով սարքերում:

            <h2>Viewport հիմունքները</h2>
            <p>Բջջային օպտիմիզացված տիպիկ կայքը պարունակում է հետևյալը.</p>

            <h3>Պատճենել clipboard-ում</h3>
            Ոչ բոլոր սարքերն են նույն լայնությունը. դուք պետք է համոզվեք, որ ձեր էջերը լավ են աշխատում էկրանի չափսերի և
            կողմնորոշումների մեծ տարբերությամբ:

            <h2>«viewport» թեգի հիմնական հատկությունները ներառում են.</h2>

            <h3>լայնությունը</h3>
            <p>Կառավարում է տեսադաշտի չափը: Այն կարող է սահմանվել պիքսելների որոշակի քանակի, օրինակ՝
                width=600 կամ սարքի լայնության հատուկ արժեքի, որը կազմում է 100vw կամ տեսադաշտի
                լայնության 100%-ը: Նվազագույնը՝ 1. Առավելագույնը՝ 10000. Բացասական արժեքներ՝ անտեսված։</p>

            <h3>բարձրությունը</h3>
            <p>Կառավարում է տեսադաշտի չափը: Այն կարող է սահմանվել պիքսելների որոշակի քանակի,
                օրինակ՝ height=400 կամ սարքի բարձրության հատուկ արժեքի, որը կազմում է 100 վժ
                կամ տեսադաշտի բարձրության 100%-ը: Նվազագույնը՝ 1. Առավելագույնը՝ 10000. Բացասական արժեքներ՝ անտեսված։
            </p>
            <h3>նախնական սանդղակ</h3>
            <p>Կառավարում է խոշորացման մակարդակը, երբ էջն առաջին անգամ բեռնվում է:
                Նվազագույնը` 0.1 Առավելագույնը՝ 10. Կանխադրված՝ 1. Բացասական արժեքներ՝ անտեսված:</p>
            <h3>նվազագույն սանդղակ</h3>
            <p>Կառավարում է, թե որքանով է թույլատրվում էջի փոքրացումը: Նվազագույնը`
                0.1 Առավելագույնը՝ 10. Կանխադրված՝ 0.1: Բացասական արժեքներ՝ անտեսված:</p>

            <h3>առավելագույն մասշտաբով</h3>
            <p>Վերահսկում է, թե որքանով է թույլատրվում խոշորացումը էջի վրա: 3-ից փոքր ցանկացած արժեք
                անհասանելի է: Նվազագույնը` 0.1 Առավելագույնը՝ 10. Կանխադրված՝ 10. Բացասական արժեքներ՝ անտեսված:</p>

            <h3>օգտագործողի կողմից մասշտաբային</h3>
            <p>Վերահսկում է, թե արդյոք թույլատրվում են մեծացնելու և փոքրացնելու գործողությունները էջում:
                Վավեր արժեքներ՝ 0, 1, այո կամ ոչ: Կանխադրված՝ 1, որը նույնն է, ինչ այո: Արժեքը 0-ի սահմանելը,
                որը նույնն է, ինչ ոչ, հակասում է Վեբ բովանդակության մատչելիության ուղեցույցներին (WCAG):</p>

            <h3>ինտերակտիվ-վիջեթ</h3>
            <p>Հատկորոշում է էջի դիտակետերի վրա ինտերակտիվ UI վիջեթները, օրինակ՝ վիրտուալ ստեղնաշարը: Վավեր արժեքներ՝
                չափափոխել-տեսողական,
                չափափոխել-բովանդակություն կամ ծածկել-բովանդակություն: Կանխադրված՝ չափափոխում-տեսողական:</p>

            <h3>Դիտակետի լայնությունը և էկրանի լայնությունը</h3>

            <p>Կայքերը կարող են իրենց տեսադաշտը սահմանել որոշակի չափի: Օրինակ,
                «լայնություն=320, սկզբնական մասշտաբ=1» սահմանումը կարող է օգտագործվել
                դիմանկարային ռեժիմում հեռախոսի փոքր էկրանի վրա ճշգրիտ տեղավորվելու
                համար: Սա կարող է խնդիրներ առաջացնել, երբ զննարկիչը ավելի մեծ չափի էջ է
                ներկայացնում: Դա շտկելու համար բրաուզերները կընդլայնեն տեսադաշտի լայնությունը,
                եթե անհրաժեշտ լինի, որպեսզի էկրանը լրացվի պահանջվող մասշտաբով: Սա հատկապես օգտակար է մեծ էկրանով
                սարքերում:</p>

            <p>Այն էջերի համար, որոնք սահմանում են սկզբնական կամ առավելագույն սանդղակ, սա նշանակում է,
                որ լայնության հատկությունը իրականում թարգմանվում է տեսադաշտի նվազագույն լայնության: Օրինակ,
                եթե ձեր դասավորության համար անհրաժեշտ է առնվազն 500 պիքսել լայնություն, ապա կարող եք օգտագործել
                հետևյալ նշումը: Երբ էկրանն ունի ավելի քան 500 պիքսել լայնություն, զննարկիչը կընդլայնի տեսադաշտը
                (այլ ոչ թե մեծացնելու)՝ էկրանին հարմարվելու համար.
                Մյուս ատրիբուտները, որոնք հասանելի են, նվազագույն մասշտաբի, առավելագույն մասշտաբի և
                օգտագործողի կողմից մասշտաբային են: Այս հատկությունները ազդում են նախնական մասշտաբի և
                լայնության վրա, ինչպես նաև սահմանափակում են խոշորացման մակարդակի փոփոխությունները:</p>
        </div>
        <div class="Hardwar">
            <h1 id="Hardwar">Hardware & Software</h1>

            <p>Համակարգչային համակարգը բաժանվում է երկու խմբի՝ Hardware եւ Software։
                Hardware-ը վերաբերում է համակարգի ֆիզիկական եւ տեսանելի բաղադրիչներին,
                ինչպիսիք են մոնիտորը, CPU-ն, ստեղնաշարը եւ մկնիկը: Մյուս կողմից,
                ծրագրային ապահովումը վերաբերում է հրահանգների մի շարք, որոնք հնարավորություն
                են տալիս hardware-ին կատարել որոշակի առաջադրանքներ: Ծրագիրը պետք է տեղադրվի
                hardware-ում, որպեսզի այն ճիշտ եւ նման կերպով գործի, hardware պետք է ներկա
                լինի առաջադրանքները կատարելու համար: Երկուսն էլ փոխկախված են,սակայն տարբերվում են նաեւ միմյանցից։
            <p>
            <h2>Սարքավորումների և ծրագրային ապահովման սարքավորումների միջև տարբերությունները(hardware and software)</h2>
            <p>Hardware-ը եւս բաժանվում է 4 հիմնական խմբի</p>
            <ul>
                <li>Մուտքային սարքեր</li>
                <li>Ելքային սարքեր</li>
                <li>Երկրորդային պահոցային սարքեր</li>
                <li>Ներքին բաղադրիչներ</li>
            </ul>

            <br>
            <p>Մշակվել է էլեկտրոնային եւ այլ նյութերի օգտագործմամբ
                Վնասված ժամանակ այն կարող է փոխարինվել նոր բաղադրիչով
                Hardware-ը ֆիզիկական բնույթ ունի, ուստի մարդը կարող է
                դիպչել եւ տեսնել hardware
                Դեղահոտը չի կարող վարակվել վիրուսներով
                Սարքերը ժամանակի ընթացքում ֆիզիկապես կհոգնեցնեն
                Hardware- ի օրինակ է hard drive- ը, մոնիտորները,
                CPU- ն, scanners- ը, printers եւ այլն:</p>
            ________________________________________
            <h2>Software</h2>
            <h4>Ծրագրային ապահովումն բաժանվում երկու հիմնական կատեգորիաների.</h4>
            <ul>
                <li>Ծրագրային ապահովման կիրառում</li>
                <li>Համակարգի ծրագրային ապահովում</li>
            </ul>

            <p>Ծրագրավորման լեզվի կիրառմամբ առաջադրանքների կիրառմամբ մշակված գրությունը
                Երբ վնասված է, այն կարելի է տեղադրել մեկ անգամ եւս՝ օգտագործելով պահեստի պատճենը
                Ծրագիրը հնարավոր չէ ֆիզիկապես դիպչել, բայց միեւնույն ժամանակ կարելի է օգտագործել եւ տեսնել
                Ծրագիրը կարող է վարակվել վիրուսներով
                Ծրագրային ապահովումը չի մաշվում, բայց այն կարող է ազդել խայթոցների եւ սոսնձների ազդեցության
                վրա
                Ծրագրային ապահովման օրինակ է Windows 10, Adobe Photoshop, Google Chrome եւ այլն:</p>
        </div>
        <div class="algoritm">
            <h1 id="my-referat">Ալգորիթմի բարդության մասին.</h1>

            <p>Ալգորիթմների բարդությունը վերաբերում է ռեսուրսների քանակին (օրինակ՝ ժամանակը կամ հիշողությունը), որը
                պահանջվում է խնդիր լուծելու կամ առաջադրանք կատարելու համար։ Բարդության ամենատարածված չափանիշը ժամանակի
                բարդությունն է, որը վերաբերում է ժամանակի քանակին, որը տևում է ալգորիթմի արդյունք ստանալու համար՝ կախված
                մուտքի չափից: Հիշողության բարդությունը վերաբերում է ալգորիթմի կողմից օգտագործվող հիշողության քանակին:
                Ալգորիթմների դիզայներները ձգտում են մշակել ալգորիթմներ հնարավորինս նվազագույն ժամանակի և հիշողության
                բարդություններով, քանի որ դա դրանք դարձնում է ավելի արդյունավետ և մասշտաբային:</p>

            <p>Ալգորիթմը վերլուծվում է՝ օգտագործելով ժամանակի բարդությունը և տարածության բարդությունը: Արդյունավետ
                ալգորիթմ գրելը օգնում է նվազագույն ժամանակ ծախսել տրամաբանության մշակման համար: A ալգորիթմի համար այն
                գնահատվում է երկու պարամետրի հիման վրա n չափի մուտքագրման համար.</p>

            <ul>
                <li>Ժամանակի բարդություն. Ալգորիթմի կողմից պահանջվող ժամանակը խնդիրը լուծելու համար: Այն չափվում է
                    օղակների կրկնության, համեմատությունների քանակի և այլնի հաշվարկով:</li>
                <li>Տիեզերական բարդություն. Ալգորիթմի կողմից վերցված տարածություն խնդիրը լուծելու համար: Այն ներառում է
                    անհրաժեշտ մուտքային փոփոխականների կողմից օգտագործվող տարածքը և ալգորիթմի կողմից օգտագործվող ցանկացած
                    հավելյալ տարածություն (բացառությամբ մուտքագրված տարածքի): Օրինակ, եթե մենք օգտագործում ենք հեշ
                    աղյուսակ (տվյալների մի տեսակ կառուցվածք), մեզ անհրաժեշտ է զանգված՝ արժեքները պահելու համար</li>
                <li>սա զբաղեցված լրացուցիչ տարածություն է, հետևաբար հաշվի կառնվի ալգորիթմի տիեզերական բարդության վրա:
                    Այս լրացուցիչ տարածքը հայտնի է որպես Օժանդակ տարածություն:</li>
            </ul>
            <h3>դեպքեր բարդության մեջ.</h3>
            <p><strong>Ալգորիթմներում բարդության երկու ընդհանուր ուսումնասիրված դեպք կա.</strong></p>

            <br>
            <p><strong>1. Լավագույն դեպքի բարդությունը.</strong> Ալգորիթմի համար լավագույն սցենարը այն սցենարն է, երբ
                ալգորիթմը կատարում է նվազագույն քանակությամբ աշխատանք (օրինակ՝ խլում է ամենակարճ ժամանակը, օգտագործում է
                նվազագույն քանակությամբ հիշողություն և այլն):
            </p>

            <p><strong>2. Վատագույն դեպքի բարդությունը.</strong> Ալգորիթմի համար ամենավատ սցենարն այն սցենարն է, երբ
                ալգորիթմը կատարում է
                առավելագույն ծավալի աշխատանք (օրինակ՝ խլում է ամենաերկար ժամանակը, օգտագործում է ամենաշատ հիշողությունը
                և ալն):</p>
            <br>
            <p>
                Ալգորիթմի բարդությունը վերլուծելիս հաճախ ավելի տեղեկատվական է ամենավատ դեպքի սցենարը ուսումնասիրելը,
                քանի
                որ սա երաշխավորված վերին սահման է տալիս ալգորիթմի կատարման վրա: Լավագույն սցենարի վերլուծությունը երբեմն
                կատարվում է, բայց ընդհանուր առմամբ ավելի քիչ կարևոր է, քանի որ այն ապահովում է ստորին սահման, որը հաճախ
                աննշան է դառնում:
            </p>
            <hr>
            <h2>Big O նշումը բացատրվում է օրինակներով</h2>
            <p>
                Big O նշումը տվյալ ալգորիթմի արագությունը կամ բարդությունը նկարագրելու միջոց է: Եթե ձեր ընթացիկ նախագիծը
                պահանջում է նախապես սահմանված ալգորիթմ, ապա կարևոր է հասկանալ, թե որքան արագ կամ դանդաղ է այն՝ համեմատած
                այլ տարբերակների հետ:
            </p>
            <h3>Ի՞նչ է Big O նշումը և ինչպես է այն աշխատում:</h3>
            <p>Պարզ ասած, Big O նշումը ցույց է տալիս ալգորիթմի գործողությունների քանակը: Այն ստացել է իր անվանումը
                բառացի «Մեծ Օ» բառից՝ վիրահատությունների գնահատված քանակի դիմաց:
            </p>


            <br>
            <p> Այն, ինչ Big O նշումը ձեզ չի ասում, դա ալգորիթմի արագությունն է վայրկյաններով: Կան չափազանց շատ
                գործոններ, որոնք ազդում են ալգորիթմի գործարկման ժամանակի վրա: Փոխարենը, դուք կօգտագործեք Big O նշումը,
                որպեսզի համեմատեք տարբեր ալգորիթմներն ըստ նրանց կատարած գործողությունների քանակի:
            </p>
            <h3>Big O-ն սահմանում է ամենավատ գործարկման ժամանակը</h3>
            <p>Պատկերացրեք, որ դուք ուսուցիչ եք Ջեյն անունով աշակերտի հետ: Դուք ցանկանում եք գտնել նրա գրառումները,
                ուստի
                օգտագործում եք պարզ որոնման ալգորիթմ՝ ձեր դպրոցական շրջանի տվյալների բազան անցնելու համար:</p>

            <br>
            <p>Դուք գիտեք, որ պարզ որոնման համար պահանջվում է O(n) անգամ: Սա նշանակում է, որ վատագույն դեպքում դուք պետք
                է
                փնտրեք յուրաքանչյուր ձայնագրություն (ներկայացված n-ով)՝ գտնելու Ջեյնի գրառումը:</p>

            <br>
            <p>Բայց երբ պարզ որոնում եք անում, տեսնում եք, որ Ջեյնի գրառումները տվյալների բազայի առաջին մուտքն են: Պետք
                չէ
                ամեն գրառում նայել. այն գտել եք ձեր առաջին փորձից:</p>

            <br>
            <p>Արդյո՞ք այս ալգորիթմը խլել է O(n) ժամանակ: Թե՞ O(1) ժամանակ է պահանջվել, քանի որ դուք գտել եք Ջեյնի
                ձայնագրությունները առաջին փորձից:</p>

            <br>
            <p>Այս դեպքում 0(1)-ը լավագույն սցենարն է. դու բախտավոր էիր, որ Ջեյնի ռեկորդները վերևում էին: Բայց Big O
                նշումը
                կենտրոնանում է ամենավատ սցենարի վրա, որը 0 (n) է պարզ որոնման համար: Դա հավաստիացում է, որ պարզ որոնումը
                երբեք ավելի դանդաղ չի լինի, քան O(n) ժամանակը:</p>
            <h3>Ալգորիթմի գործարկման ժամանակներն աճում են տարբեր տեմպերով</h3>

            <p>Մեծ O նշումը ցույց է տալիս գործողությունների քանակը
                Ինչպես նշվեց վերևում, Big O նշումը ցույց չի տալիս ալգորիթմի գործարկման ժամանակը: Փոխարենը, այն ցույց է
                տալիս այն գործողությունների քանակը, որոնք նա կկատարի: Այն պատմում է ձեզ, թե որքան արագ է աճում ալգորիթմը
                և թույլ է տալիս համեմատել այն ուրիշների հետ:
            </p>
            <h4>Ահա մի քանի ընդհանուր ալգորիթմներ և դրանց գործարկման ժամանակները Big O նշումով</h4>
            <table class="R">
                <tr>
                    <th>BIG O NOTATION</th>
                    <th>EXAMPLE ALGORITHM</th>
                </tr>

                <tr>
                    <th>O(log n)</th>
                    <th>Երկուական որոնում</th>
                </tr>

                <tr>
                    <th>O(n)</th>
                    <th>Պարզ որոնում</th>
                </tr>

                <tr>
                    <th>O(n * log n)</th>
                    <th>Արագ տեսակավորում</th>
                </tr>

                <tr>
                    <th>O(n2)</th>
                    <th>Ընտրության տեսակավորում</th>
                </tr>

                <tr>
                    <th>O(n!)</th>
                    <th>Traveling salesperson</th>
                </tr>
            </table>
        </div>
        <div class="operators">
            <h1 id="operators">Operators</h1>
            <p>Բարձր մակարդակում արտահայտությունը կոդի վավերական միավոր է, որը որոշում է արժեքը։ Գոյություն ունեն երկու
                տեսակի արտահայտություններ՝ դրանք, որոնք ունեն կողմնակի ազդեցություններ (օրինակ՝ նշանակել արժեքներ) եւ
                այնպիսի արտահայտություններ, որոնք զուտ գնահատում են։ </p>

            <br>
            <p>x = 7 արտահայտությունը առաջին տիպի օրինակ է։ Այս արտահայտությունը օգտագործում է = օպերատորը, որպեսզի յոթի
                արժեքը նշանակի փոփոխական x- ին: Արտահայտությունն ինքնին գնահատում է 7. </p>
            <br>
            <p>3 + 4 արտահայտությունը երկրորդ տիպի օրինակ է։ Այս արտահայտությունը օգտագործում է + օպերատորը միասին
                ավելացնելով 3 եւ 4 եւ արտադրել արժեք, 7. Սակայն, եթե այն ի վերջո մաս չի կազմում ավելի մեծ կառուցման
                (օրինակ, փոփոխական հայտարարի, ինչպես const z = 3 + 4), դրա արդյունքը անմիջապես կթողարկվի. սա սովորաբար
                ծրագրավորողի սխալ է, քանի որ գնահատումը ոչ մի ազդեցություն չի առաջացնում: </p>
            <br>
            <p>Ինչպես ցույց են տալիս վերը բերված օրինակները, բոլոր բարդ արտահայտությունները միացվում են օպերատորների
                կողմից, օրինակ՝ = եւ +: Այս բաժնում կներկայացնենք հետեւյալ օպերատորներին. </p>
            <ul>
                <li>Հանձնարարական օպերատորներ (Assignment operators)</li>
                <li>Համեմատական օպերատորներ (Comparison operators)</li>
                <li>Թվաբանության օպերատորներ (Arithmetic operators)</li>
                <li>Bitwise օպերատորներ (Bitwise operators)</li>
                <li>Տրամաբանական օպերատորներ (Logical operators)</li>
                <li>BigInt օպերատորներ (BigInt operators)</li>
                <li>Լարային օպերատորներ (String operators)</li>
                <li>Պայմանական (ternary) օպերատոր (Conditional (ternary) operator)</li>
                <li>Կոմմա օպերատոր (Comma operator)</li>
                <li>Unary օպերատորներ (Unary operators)</li>
                <li>Ռելյատիվիստական օպերատորներ (Relativistic operators)</li>
            </ul>

            <br>
            <p>Այս օպերատորները միանում են օպերաներին, որոնք ձեւավորվում են կա՛մ ավելի բարձր նախապատմության օպերատորների
                կողմից, կա՛մ էլ հիմնական արտահայտություններից մեկը։ Հղումում առկա է նաեւ օպերատորների եւ
                արտահայտությունների ամբողջական եւ մանրամասն ցանկը:</p>

            <br>
            <p>JavaScript-ն ունի եւ՛ բինար, եւ՛ unary օպերատորներ, եւ մեկ հատուկ տերնար օպերատոր՝ պայմանական </p>
            օպերատոր:
            <p>X=X+10; X+=10;
                <br>Y=Y/12; Y/=12;
                <br>Z=Z*40; Z*=40;
                <br>A = A**8; A **=8;
                <br> x=7
                X = X + 14; || X +=14;
            </p>

            <h2>Հանձնարարական օպերատորներ</h2>
            <img src="mn.png" alt="hatuk">

            <h2>Համեմատական օպերատորներ (Comparison operators)</h2>
            <table>
                <tr class="table4">
                    <th>Օպերատոր</th>
                    <th>Նկարագրություն</th>
                    <th>Ճշմարիտ վերադարձող օրինակներ</th>
                </tr>

                <tr>
                    <th>Հավասար (==)</th>
                    <th>Վերադարձնում է true, եթե օպերանդները հավասար են:</th>
                    <th><br>3 == var1
                        <br> "3" == var1
                        <br> 3 == '3'
                    </th>
                </tr>

                <tr>
                    <th>Խիստ հավասար (===)</th>
                    <th>Վերադարձնում է true, եթե օպերանդները հավասար են և նույն տիպի: Տես նաև Object.is
                        ևնույնականությունը JS-ում:</th>
                    <th>3 === var1</th>
                </tr>

                <tr>
                    <th>Ոչ հավասար (!=)</th>
                    <th>Վերադարձնում է true, եթե օպերանդները հավասար չեն:</th>
                    <th><br>var1 != 4
                        <br>var2 != "3"
                    </th>
                </tr>

                <tr>
                    <th>Խիստ ոչ հավասար (!==)</th>
                    <th>Վերադարձնում է true, եթե օպերանդները նույն տեսակի են, բայց ոչ հավասար, կամ տարբեր տեսակի են:
                    </th>
                    <th><br>var1 !== "3"
                        <br>3 !== '3'

                    </th>
                </tr>

                <tr>
                    <th>Ավելի մեծ, քան (>)</th>
                    <th>Վերադարձնում է true, եթե ձախ օպերանդը մեծ է աջ օպերանդից:</th>
                    <th><br>var2 > var1
                        <br>"12" > 2
                    </th>
                </tr>


                <tr>
                    <th>Մեծ կամ հավասար (>=)</th>
                    <th>Վերադարձնում է true, եթե ձախ օպերանդը մեծ է կամ հավասար է աջ օպերանդին:</th>
                    <th><br>var2 >= var1
                        <br>var1 >= 3

                    </th>
                </tr>

                <tr>
                    <th>Պակաս, քան (>hak.)</th>
                    <th>Վերադարձնում է true, եթե ձախ օպերանդը փոքր է աջ օպերանդից:</th>
                    <th><br>var1 փոքրի նշան var2
                        <br>"2" փոքրի նշան 12
                    </th>
                </tr>

                <tr>
                    <th>4-ից փոքր կամ հավասար (>hak.=)</th>
                    <th>Վերադարձնում է true, եթե ձախ օպերանդը փոքր է կամ հավասար է աջ օպերանդին:</th>
                    <th><br>var1 = var2
                        <br>var2 փոքրի նշան= 5

                    </th>
                </tr>
            </table>
<h2>Թվաբանական օպերատորներ (Arithmetic operators)</h2>
    <img src="arit.jpg" alt="hatuk">
        </div>



    </div>
</body>

</html>